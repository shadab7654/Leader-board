{"ast":null,"code":"import _isPlainObject from 'lodash/isPlainObject';\nimport _isFunction from 'lodash/isFunction';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp2;\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Render sectors of a pie\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Animate from 'react-smooth';\nimport classNames from 'classnames';\nimport pureRender from '../util/PureRender';\nimport Layer from '../container/Layer';\nimport Sector from '../shape/Sector';\nimport Curve from '../shape/Curve';\nimport Text from '../component/Text';\nimport { PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, LEGEND_TYPES, getPresentationAttributes, filterEventsOfChild, isSsr } from '../util/ReactUtils';\nimport { polarToCartesian } from '../util/PolarUtils';\nimport AnimationDecorator from '../util/AnimationDecorator';\nimport { isNumber, getValueByDataKey, uniqueId, mathSign } from '../util/DataUtils';\nvar Pie = AnimationDecorator(_class = pureRender(_class = (_temp2 = _class2 = function (_Component) {\n  _inherits(Pie, _Component);\n  function Pie() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, Pie);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Pie.__proto__ || Object.getPrototypeOf(Pie)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      isAnimationFinished: false\n    }, _this.id = uniqueId('recharts-pie-'), _this.handleAnimationEnd = function () {\n      _this.setState({\n        isAnimationFinished: true\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(Pie, [{\n    key: 'getDeltaAngle',\n    value: function getDeltaAngle() {\n      var _props = this.props,\n        startAngle = _props.startAngle,\n        endAngle = _props.endAngle;\n      var sign = mathSign(endAngle - startAngle);\n      var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n      return sign * deltaAngle;\n    }\n  }, {\n    key: 'getSectors',\n    value: function getSectors(data) {\n      var _props2 = this.props,\n        cx = _props2.cx,\n        cy = _props2.cy,\n        innerRadius = _props2.innerRadius,\n        outerRadius = _props2.outerRadius,\n        cornerRadius = _props2.cornerRadius,\n        startAngle = _props2.startAngle,\n        paddingAngle = _props2.paddingAngle,\n        minAngle = _props2.minAngle,\n        nameKey = _props2.nameKey,\n        valueKey = _props2.valueKey;\n      var len = data.length;\n      var deltaAngle = this.getDeltaAngle();\n      var absDeltaAngle = Math.abs(deltaAngle);\n      var totalPadingAngle = (absDeltaAngle >= 360 ? len : len - 1) * paddingAngle;\n      var sum = data.reduce(function (result, entry) {\n        return result + getValueByDataKey(entry, valueKey, 0);\n      }, 0);\n      var sectors = [];\n      var prev = void 0;\n      if (sum > 0) {\n        sectors = data.map(function (entry, i) {\n          var percent = getValueByDataKey(entry, valueKey, 0) / sum;\n          var tempStartAngle = void 0;\n          if (i) {\n            tempStartAngle = (deltaAngle < 0 ? prev.endAngle : prev.startAngle) + mathSign(deltaAngle) * paddingAngle;\n          } else {\n            tempStartAngle = startAngle;\n          }\n          var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * (minAngle + percent * (absDeltaAngle - len * minAngle - totalPadingAngle));\n          prev = _extends({\n            percent: percent,\n            cornerRadius: cornerRadius\n          }, entry, {\n            cx: cx,\n            cy: cy,\n            innerRadius: innerRadius,\n            outerRadius: outerRadius,\n            name: getValueByDataKey(entry, nameKey),\n            value: getValueByDataKey(entry, valueKey),\n            startAngle: deltaAngle < 0 ? tempStartAngle : tempEndAngle,\n            endAngle: deltaAngle < 0 ? tempEndAngle : tempStartAngle,\n            midAngle: (tempStartAngle + tempEndAngle) / 2\n          });\n          return prev;\n        });\n      }\n      return sectors;\n    }\n  }, {\n    key: 'getTextAnchor',\n    value: function getTextAnchor(x, cx) {\n      if (x > cx) {\n        return 'start';\n      } else if (x < cx) {\n        return 'end';\n      }\n      return 'middle';\n    }\n  }, {\n    key: 'isActiveIndex',\n    value: function isActiveIndex(i) {\n      var activeIndex = this.props.activeIndex;\n      if (Array.isArray(activeIndex)) {\n        return activeIndex.indexOf(i) !== -1;\n      }\n      return i === activeIndex;\n    }\n  }, {\n    key: 'renderClipPath',\n    value: function renderClipPath() {\n      var _props3 = this.props,\n        cx = _props3.cx,\n        cy = _props3.cy,\n        maxRadius = _props3.maxRadius,\n        startAngle = _props3.startAngle,\n        isAnimationActive = _props3.isAnimationActive,\n        animationDuration = _props3.animationDuration,\n        animationEasing = _props3.animationEasing,\n        animationBegin = _props3.animationBegin,\n        animationId = _props3.animationId;\n      return React.createElement('defs', null, React.createElement('clipPath', {\n        id: this.id\n      }, React.createElement(Animate, {\n        easing: animationEasing,\n        isActive: isAnimationActive,\n        duration: animationDuration,\n        key: animationId,\n        animationBegin: animationBegin,\n        onAnimationEnd: this.handleAnimationEnd,\n        from: {\n          endAngle: startAngle\n        },\n        to: {\n          outerRadius: Math.max(this.props.outerRadius, maxRadius || 0),\n          innerRadius: 0,\n          endAngle: this.props.endAngle\n        }\n      }, function (_ref2) {\n        var outerRadius = _ref2.outerRadius,\n          innerRadius = _ref2.innerRadius,\n          endAngle = _ref2.endAngle;\n        return React.createElement(Sector, {\n          cx: cx,\n          cy: cy,\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          startAngle: startAngle,\n          endAngle: endAngle\n        });\n      })));\n    }\n  }, {\n    key: 'renderLabelLineItem',\n    value: function renderLabelLineItem(option, props) {\n      if (React.isValidElement(option)) {\n        return React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        return option(props);\n      }\n      return React.createElement(Curve, _extends({}, props, {\n        type: 'linear',\n        className: 'recharts-pie-label-line'\n      }));\n    }\n  }, {\n    key: 'renderLabelItem',\n    value: function renderLabelItem(option, props, value) {\n      if (React.isValidElement(option)) {\n        return React.cloneElement(option, props);\n      }\n      var label = value;\n      if (_isFunction(option)) {\n        label = option(props);\n        if (React.isValidElement(label)) {\n          return label;\n        }\n      }\n      return React.createElement(Text, _extends({}, props, {\n        alignmentBaseline: 'middle',\n        className: 'recharts-pie-label-text'\n      }), label);\n    }\n  }, {\n    key: 'renderLabels',\n    value: function renderLabels(sectors) {\n      var _this2 = this;\n      var isAnimationActive = this.props.isAnimationActive;\n      if (isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props4 = this.props,\n        label = _props4.label,\n        labelLine = _props4.labelLine,\n        valueKey = _props4.valueKey;\n      var pieProps = getPresentationAttributes(this.props);\n      var customLabelProps = getPresentationAttributes(label);\n      var customLabelLineProps = getPresentationAttributes(labelLine);\n      var offsetRadius = label && label.offsetRadius || 20;\n      var labels = sectors.map(function (entry, i) {\n        var midAngle = (entry.startAngle + entry.endAngle) / 2;\n        var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);\n        var labelProps = _extends({}, pieProps, entry, {\n          stroke: 'none'\n        }, customLabelProps, {\n          index: i,\n          textAnchor: _this2.getTextAnchor(endPoint.x, entry.cx)\n        }, endPoint);\n        var lineProps = _extends({}, pieProps, entry, {\n          fill: 'none',\n          stroke: entry.fill\n        }, customLabelLineProps, {\n          points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint]\n        });\n        return React.createElement(Layer, {\n          key: 'label-' + i\n        }, labelLine && _this2.renderLabelLineItem(labelLine, lineProps), _this2.renderLabelItem(label, labelProps, getValueByDataKey(entry, valueKey)));\n      });\n      return React.createElement(Layer, {\n        className: 'recharts-pie-labels'\n      }, labels);\n    }\n  }, {\n    key: 'renderSectorItem',\n    value: function renderSectorItem(option, props) {\n      if (React.isValidElement(option)) {\n        return React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        return option(props);\n      } else if (_isPlainObject(option)) {\n        return React.createElement(Sector, _extends({}, props, option));\n      }\n      return React.createElement(Sector, props);\n    }\n  }, {\n    key: 'renderSectors',\n    value: function renderSectors(sectors) {\n      var _this3 = this;\n      var activeShape = this.props.activeShape;\n      return sectors.map(function (entry, i) {\n        return React.createElement(Layer, _extends({\n          className: 'recharts-pie-sector'\n        }, filterEventsOfChild(_this3.props, entry, i), {\n          key: 'sector-' + i\n        }), _this3.renderSectorItem(_this3.isActiveIndex(i) ? activeShape : null, entry));\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props5 = this.props,\n        data = _props5.data,\n        composedData = _props5.composedData,\n        className = _props5.className,\n        label = _props5.label,\n        cx = _props5.cx,\n        cy = _props5.cy,\n        innerRadius = _props5.innerRadius,\n        outerRadius = _props5.outerRadius;\n      var pieData = composedData || data;\n      if (!pieData || !pieData.length || !isNumber(cx) || !isNumber(cy) || !isNumber(innerRadius) || !isNumber(outerRadius)) {\n        return null;\n      }\n      var sectors = this.getSectors(pieData);\n      var layerClass = classNames('recharts-pie', className);\n      return React.createElement(Layer, {\n        className: layerClass\n      }, this.renderClipPath(), React.createElement('g', {\n        clipPath: 'url(#' + this.id + ')'\n      }, this.renderSectors(sectors)), label && this.renderLabels(sectors));\n    }\n  }]);\n  return Pie;\n}(Component), _class2.displayName = 'Pie', _class2.propTypes = _extends({}, PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, {\n  className: PropTypes.string,\n  animationId: PropTypes.number,\n  cx: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  cy: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  startAngle: PropTypes.number,\n  endAngle: PropTypes.number,\n  paddingAngle: PropTypes.number,\n  innerRadius: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  outerRadius: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  cornerRadius: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  nameKey: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  valueKey: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  data: PropTypes.arrayOf(PropTypes.object),\n  composedData: PropTypes.arrayOf(PropTypes.object),\n  minAngle: PropTypes.number,\n  legendType: PropTypes.oneOf(LEGEND_TYPES),\n  maxRadius: PropTypes.number,\n  labelLine: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.element, PropTypes.bool]),\n  label: PropTypes.oneOfType([PropTypes.shape({\n    offsetRadius: PropTypes.number\n  }), PropTypes.func, PropTypes.element, PropTypes.bool]),\n  activeShape: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.element]),\n  activeIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  isAnimationActive: PropTypes.bool,\n  animationBegin: PropTypes.number,\n  animationDuration: PropTypes.number,\n  animationEasing: PropTypes.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'spring', 'linear'])\n}), _class2.defaultProps = {\n  stroke: '#fff',\n  fill: '#808080',\n  legendType: 'rect',\n  // The abscissa of pole\n  cx: '50%',\n  // The ordinate of pole\n  cy: '50%',\n  // The start angle of first sector\n  startAngle: 0,\n  // The direction of drawing sectors\n  endAngle: 360,\n  // The inner radius of sectors\n  innerRadius: 0,\n  // The outer radius of sectors\n  outerRadius: '80%',\n  paddingAngle: 0,\n  nameKey: 'name',\n  valueKey: 'value',\n  labelLine: true,\n  data: [],\n  minAngle: 0,\n  isAnimationActive: !isSsr(),\n  animationBegin: 400,\n  animationDuration: 1500,\n  animationEasing: 'ease'\n}, _temp2)) || _class) || _class;\nexport default Pie;","map":null,"metadata":{},"sourceType":"module"}