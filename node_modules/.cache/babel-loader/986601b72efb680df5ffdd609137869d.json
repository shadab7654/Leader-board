{"ast":null,"code":"import _isFunction from 'lodash/isFunction';\nimport _isArray from 'lodash/isArray';\nimport _isNil from 'lodash/isNil';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _dec, _class, _class2, _temp;\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Area Chart\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Smooth from 'react-smooth';\nimport Layer from '../container/Layer';\nimport Tooltip from '../component/Tooltip';\nimport Dot from '../shape/Dot';\nimport Curve from '../shape/Curve';\nimport { getPresentationAttributes, findChildByType } from '../util/ReactUtils';\nimport { getMainColorOfGraphicItem } from '../util/CartesianUtils';\nimport { isNumber, getValueByDataKey } from '../util/DataUtils';\nimport generateCategoricalChart from './generateCategoricalChart';\nimport Area from '../cartesian/Area';\nimport AnimationDecorator from '../util/AnimationDecorator';\nimport composedDataDecorator from '../util/ComposedDataDecorator';\nvar getCategoryAxisCoordinate = function getCategoryAxisCoordinate(_ref) {\n  var axis = _ref.axis,\n    ticks = _ref.ticks,\n    bandSize = _ref.bandSize,\n    entry = _ref.entry,\n    index = _ref.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nvar getBaseValue = function getBaseValue(props, xAxis, yAxis) {\n  var layout = props.layout,\n    baseValue = props.baseValue;\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n  var numberAxis = layout === 'horizontal' ? yAxis : xAxis;\n  var domain = numberAxis.scale.domain();\n  if (numberAxis.type === 'number') {\n    var max = Math.max(domain[0], domain[1]);\n    var min = Math.min(domain[0], domain[1]);\n    if (baseValue === 'dataMin') {\n      return min;\n    }\n    if (baseValue === 'dataMax') {\n      return max;\n    }\n    return max < 0 ? max : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n  return domain[0];\n};\n\n/**\n * Compose the data of each area\n * @param {Object} props The props that are passed to the component\n * @param {Object} xAxis       The configuration of x-axis\n * @param {Object} yAxis       The configuration of y-axis\n * @param {String} dataKey     The unique key of a group\n * @param {Array} stackedData If the area is stacked,\n * the stackedData is an array of min value and max value\n * @return {Array} Composed data\n */\nvar getComposedData = function getComposedData(_ref2) {\n  var props = _ref2.props,\n    xAxis = _ref2.xAxis,\n    yAxis = _ref2.yAxis,\n    xTicks = _ref2.xTicks,\n    yTicks = _ref2.yTicks,\n    bandSize = _ref2.bandSize,\n    dataKey = _ref2.dataKey,\n    stackedData = _ref2.stackedData;\n  var layout = props.layout,\n    dataStartIndex = props.dataStartIndex,\n    dataEndIndex = props.dataEndIndex;\n  var data = props.data.slice(dataStartIndex, dataEndIndex + 1);\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(props, xAxis, yAxis);\n  var isRange = false;\n  var points = data.map(function (entry, index) {\n    var value = void 0;\n    if (hasStack) {\n      value = stackedData[dataStartIndex + index];\n    } else {\n      value = getValueByDataKey(entry, dataKey);\n      if (!_isArray(value)) {\n        value = [baseValue, value];\n      } else {\n        isRange = true;\n      }\n    }\n    if (layout === 'horizontal') {\n      return {\n        x: getCategoryAxisCoordinate({\n          axis: xAxis,\n          ticks: xTicks,\n          bandSize: bandSize,\n          entry: entry,\n          index: index\n        }),\n        y: _isNil(value[1]) ? null : yAxis.scale(value[1]),\n        value: value,\n        payload: entry\n      };\n    }\n    return {\n      x: _isNil(value[1]) ? null : xAxis.scale(value[1]),\n      y: getCategoryAxisCoordinate({\n        axis: yAxis,\n        ticks: yTicks,\n        bandSize: bandSize,\n        entry: entry,\n        index: index\n      }),\n      value: value,\n      payload: entry\n    };\n  });\n  var baseLine = void 0;\n  if (hasStack || isRange) {\n    baseLine = points.map(function (entry) {\n      return {\n        x: layout === 'horizontal' ? entry.x : xAxis.scale(entry && entry.value[0]),\n        y: layout === 'horizontal' ? yAxis.scale(entry && entry.value[0]) : entry.y\n      };\n    });\n  } else if (layout === 'horizontal') {\n    baseLine = yAxis.scale(baseValue);\n  } else {\n    baseLine = xAxis.scale(baseValue);\n  }\n  return {\n    points: points,\n    baseLine: baseLine,\n    layout: layout,\n    isRange: isRange\n  };\n};\nexport var AreaChart = (_dec = composedDataDecorator({\n  getComposedData: getComposedData\n}), AnimationDecorator(_class = _dec(_class = (_temp = _class2 = function (_Component) {\n  _inherits(AreaChart, _Component);\n  function AreaChart() {\n    _classCallCheck(this, AreaChart);\n    return _possibleConstructorReturn(this, (AreaChart.__proto__ || Object.getPrototypeOf(AreaChart)).apply(this, arguments));\n  }\n  _createClass(AreaChart, [{\n    key: 'renderCursor',\n    value: function renderCursor(_ref3) {\n      var offset = _ref3.offset;\n      var _props = this.props,\n        children = _props.children,\n        isTooltipActive = _props.isTooltipActive,\n        layout = _props.layout,\n        activeTooltipIndex = _props.activeTooltipIndex,\n        axisTicks = _props.axisTicks;\n      var tooltipItem = findChildByType(children, Tooltip);\n      if (!tooltipItem || !tooltipItem.props.cursor || !isTooltipActive || activeTooltipIndex < 0) {\n        return null;\n      }\n      var ticks = axisTicks;\n      if (!ticks || !ticks[activeTooltipIndex]) {\n        return null;\n      }\n      var start = ticks[activeTooltipIndex].coordinate;\n      var x1 = layout === 'horizontal' ? start : offset.left;\n      var y1 = layout === 'horizontal' ? offset.top : start;\n      var x2 = layout === 'horizontal' ? start : offset.left + offset.width;\n      var y2 = layout === 'horizontal' ? offset.top + offset.height : start;\n      var cursorProps = _extends({\n        stroke: '#ccc'\n      }, getPresentationAttributes(tooltipItem.props.cursor), {\n        points: [{\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        }]\n      });\n      return React.isValidElement(tooltipItem.props.cursor) ? React.cloneElement(tooltipItem.props.cursor, cursorProps) : React.createElement(Curve, _extends({}, cursorProps, {\n        type: 'linear',\n        className: 'recharts-tooltip-cursor'\n      }));\n    }\n  }, {\n    key: 'renderActiveDot',\n    value: function renderActiveDot(option, props, childIndex) {\n      var dot = void 0;\n      if (React.isValidElement(option)) {\n        dot = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        dot = option(props);\n      } else {\n        dot = React.createElement(Dot, props);\n      }\n      return React.createElement(Smooth, {\n        from: 'scale(0)',\n        to: 'scale(1)',\n        duration: 400,\n        key: 'dot-' + childIndex + '-' + props.pointType,\n        attributeName: 'transform'\n      }, React.createElement(Layer, {\n        style: {\n          transformOrigin: 'center center'\n        }\n      }, dot));\n    }\n\n    /**\n     * Draw the main part of area chart\n     * @param  {Array} items     React elements of Area\n     * @param  {Object} xAxisMap The configuration of all x-axis\n     * @param  {Object} yAxisMap The configuration of all y-axis\n     * @param  {Object} offset   The offset of main part in the svg element\n     * @param  {Array} allComposedData The array of pre-created composedData\n     *                                 {points, basedLine, layout} for each item\n     * @return {ReactComponent} The instances of Area\n     */\n  }, {\n    key: 'renderItems',\n    value: function renderItems(items, xAxisMap, yAxisMap, offset, allComposedData) {\n      var _this2 = this;\n      var _props2 = this.props,\n        children = _props2.children,\n        layout = _props2.layout,\n        isTooltipActive = _props2.isTooltipActive,\n        activeTooltipIndex = _props2.activeTooltipIndex;\n      var tooltipItem = findChildByType(children, Tooltip);\n      var hasDot = tooltipItem && isTooltipActive;\n      var dotItems = [];\n      var animationId = this.props.animationId;\n      var areaItems = items.reduce(function (result, child, i) {\n        var _child$props = child.props,\n          dataKey = _child$props.dataKey,\n          activeDot = _child$props.activeDot;\n        var currentComposedData = allComposedData[i];\n        var isRange = currentComposedData.isRange;\n        var activePoint = currentComposedData.points && currentComposedData.points[activeTooltipIndex];\n        var basePoint = isRange && currentComposedData.baseLine && currentComposedData.baseLine[activeTooltipIndex];\n        if (hasDot && activeDot && activePoint) {\n          var dotProps = _extends({\n            index: activeTooltipIndex,\n            dataKey: dataKey,\n            animationId: animationId,\n            cx: activePoint.x,\n            cy: activePoint.y,\n            r: 4,\n            fill: getMainColorOfGraphicItem(child),\n            strokeWidth: 2,\n            stroke: '#fff',\n            payload: activePoint.payload,\n            value: activePoint.value,\n            pointType: 'activePoint'\n          }, getPresentationAttributes(activeDot));\n          dotItems.push(_this2.renderActiveDot(activeDot, dotProps, i));\n          if (basePoint) {\n            dotItems.push(_this2.renderActiveDot(activeDot, _extends({}, dotProps, {\n              cx: basePoint.x,\n              cy: basePoint.y,\n              pointType: 'basePoint'\n            }), i));\n          }\n        }\n        var area = React.cloneElement(child, _extends({\n          key: child.key || 'area-' + i\n        }, currentComposedData, offset, {\n          animationId: animationId,\n          layout: layout,\n          xAxis: xAxisMap[child.props.xAxisId],\n          yAxis: yAxisMap[child.props.yAxisId]\n        }));\n        return [].concat(_toConsumableArray(result), [area]);\n      }, []);\n      return React.createElement(Layer, {\n        className: 'recharts-area-chart-group'\n      }, React.createElement(Layer, {\n        className: 'recharts-area-chart-shapes'\n      }, areaItems), React.createElement(Layer, {\n        className: 'recharts-area-chart-dots'\n      }, dotItems));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n        isComposed = _props3.isComposed,\n        graphicalItems = _props3.graphicalItems,\n        xAxisMap = _props3.xAxisMap,\n        yAxisMap = _props3.yAxisMap,\n        offset = _props3.offset,\n        allComposedData = _props3.allComposedData;\n      return React.createElement(Layer, {\n        className: 'recharts-area-graphical'\n      }, !isComposed && this.renderCursor({\n        xAxisMap: xAxisMap,\n        yAxisMap: yAxisMap,\n        offset: offset\n      }), this.renderItems(graphicalItems, xAxisMap, yAxisMap, offset, allComposedData));\n    }\n  }]);\n  return AreaChart;\n}(Component), _class2.displayName = 'AreaChart', _class2.propTypes = {\n  allComposedData: PropTypes.array,\n  axisTicks: PropTypes.array,\n  layout: PropTypes.oneOf(['horizontal', 'vertical']),\n  dataStartIndex: PropTypes.number,\n  dataEndIndex: PropTypes.number,\n  data: PropTypes.array,\n  isTooltipActive: PropTypes.bool,\n  activeTooltipIndex: PropTypes.number,\n  xAxisMap: PropTypes.object,\n  yAxisMap: PropTypes.object,\n  offset: PropTypes.object,\n  graphicalItems: PropTypes.array,\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n  stackGroups: PropTypes.object,\n  baseValue: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['dataMin', 'dataMax', 'auto'])]),\n  // used internally\n  isComposed: PropTypes.bool,\n  animationId: PropTypes.number\n}, _class2.defaultProps = {\n  baseValue: 'auto'\n}, _temp)) || _class) || _class);\nexport default generateCategoricalChart(AreaChart, Area);","map":null,"metadata":{},"sourceType":"module"}