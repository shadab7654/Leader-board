{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp2;\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Scatter Chart\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Surface from '../container/Surface';\nimport Layer from '../container/Layer';\nimport Cell from '../component/Cell';\nimport Legend from '../component/Legend';\nimport Tooltip from '../component/Tooltip';\nimport Cross from '../shape/Cross';\nimport CartesianAxis from '../cartesian/CartesianAxis';\nimport CartesianGrid from '../cartesian/CartesianGrid';\nimport Scatter from '../cartesian/Scatter';\nimport XAxis from '../cartesian/XAxis';\nimport YAxis from '../cartesian/YAxis';\nimport ZAxis from '../cartesian/ZAxis';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport { EVENT_ATTRIBUTES, getPresentationAttributes, findChildByType, filterSvgElements, findAllByType, validateWidthHeight, getDisplayName, filterEventAttributes } from '../util/ReactUtils';\nimport pureRender from '../util/PureRender';\nimport { parseSpecifiedDomain, isNumber, parseScale, getValueByDataKey } from '../util/DataUtils';\nimport { warn } from '../util/LogUtils';\nimport { appendOffsetOfLegend, detectReferenceElementsDomain, getTicksOfAxis, getCoordinatesOfGrid, getLegendProps, getTicksOfScale } from '../util/CartesianUtils';\nvar ScatterChart = pureRender(_class = (_temp2 = _class2 = function (_Component) {\n  _inherits(ScatterChart, _Component);\n  function ScatterChart() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, ScatterChart);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      activeTooltipCoord: {\n        x: 0,\n        y: 0\n      },\n      isTooltipActive: false,\n      activeItem: null\n    }, _this.handleLegendBBoxUpdate = function (box) {\n      if (box && _this.legendInstance) {\n        _this.forceUpdate();\n      }\n    }, _this.handleScatterMouseEnter = function (el) {\n      _this.setState({\n        isTooltipActive: true,\n        activeItem: el,\n        activeTooltipCoord: {\n          x: el.cx,\n          y: el.cy\n        }\n      });\n    }, _this.handleScatterMouseLeave = function () {\n      _this.setState({\n        isTooltipActive: false\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(ScatterChart, [{\n    key: 'getComposedData',\n    /**\n     * Compose the data of each group\n     * @param  {Object} item        An instance of Scatter\n     * @param  {Array}  data        The original data\n     * @param  {Object} xAxis       The configuration of x-axis\n     * @param  {Object} yAxis       The configuration of y-axis\n     * @param  {Object} zAxis       The configuration of z-axis\n     * @return {Array} Composed data\n     */\n    value: function getComposedData(item, data, xAxis, yAxis, zAxis) {\n      var children = item.props.children;\n      var xAxisDataKey = xAxis.dataKey;\n      var yAxisDataKey = yAxis.dataKey;\n      var zAxisDataKey = zAxis.dataKey;\n      var cells = findAllByType(children, Cell);\n      return data.map(function (entry, index) {\n        return _extends({}, entry, {\n          cx: isNumber(entry[xAxisDataKey]) ? xAxis.scale(entry[xAxisDataKey]) : null,\n          cy: isNumber(entry[yAxisDataKey]) ? yAxis.scale(entry[yAxisDataKey]) : null,\n          size: zAxisDataKey !== undefined && isNumber(entry[zAxisDataKey]) ? zAxis.scale(entry[zAxisDataKey]) : zAxis.range[0],\n          node: {\n            x: entry[xAxisDataKey],\n            y: entry[yAxisDataKey],\n            z: zAxisDataKey !== undefined && entry[zAxisDataKey] || '-'\n          },\n          payload: entry\n        }, cells && cells[index] && cells[index].props);\n      });\n    }\n  }, {\n    key: 'getDomain',\n    value: function getDomain(items, dataKey, axisId, axisType) {\n      var domain = items.reduce(function (result, item) {\n        return result.concat(item.props.data.map(function (entry) {\n          return getValueByDataKey(entry, dataKey);\n        }));\n      }, []);\n      if (axisType === 'xAxis' || axisType === 'yAxis') {\n        domain = detectReferenceElementsDomain(this.props.children, domain, axisId, axisType);\n      }\n      return [Math.min.apply(null, domain), Math.max.apply(null, domain)];\n    }\n\n    /**\n     * Get the configuration of x-axis or y-axis\n     * @param  {String} axisType The type of axis\n     * @param  {Array} items     The instances of item\n     * @return {Object}          Configuration\n     */\n  }, {\n    key: 'getAxis',\n    value: function getAxis() {\n      var axisType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xAxis';\n      var items = arguments[1];\n      var children = this.props.children;\n      var Axis = axisType === 'xAxis' ? XAxis : YAxis;\n      var axis = findChildByType(children, Axis);\n      warn(axis, 'recharts: ScatterChart must has %s', Axis.displayName);\n      if (axis) {\n        var domain = parseSpecifiedDomain(axis.props.domain, this.getDomain(items, axis.props.dataKey, axis.props[axisType + 'Id'], axisType), axis.props.allowDataOverflow);\n        return _extends({}, axis.props, {\n          axisType: axisType,\n          domain: domain,\n          type: 'number',\n          originalDomain: axis.props.domain\n        });\n      }\n      return null;\n    }\n\n    /**\n     * Get the configuration of z-axis\n     * @param  {Array} items The instances of item\n     * @return {Object}      Configuration\n     */\n  }, {\n    key: 'getZAxis',\n    value: function getZAxis(items) {\n      var children = this.props.children;\n      var axisItem = findChildByType(children, ZAxis);\n      var axisProps = axisItem && axisItem.props || ZAxis.defaultProps;\n      var domain = axisProps.dataKey ? this.getDomain(items, axisProps.dataKey) : [-1, 1];\n      return _extends({}, axisProps, {\n        domain: domain,\n        scale: parseScale(axisProps).domain(domain).range(axisProps.range)\n      });\n    }\n  }, {\n    key: 'getOffset',\n    value: function getOffset(items, xAxis, yAxis) {\n      var _props = this.props,\n        width = _props.width,\n        height = _props.height,\n        margin = _props.margin,\n        children = _props.children;\n      var legendItem = findChildByType(children, Legend);\n      var offset = {\n        left: margin.left || 0,\n        right: margin.right || 0,\n        top: margin.top || 0,\n        bottom: margin.bottom || 0\n      };\n      if (!xAxis.hide && !xAxis.mirror) {\n        offset[xAxis.orientation] += xAxis.height;\n      }\n      if (!yAxis.hide && !yAxis.mirror) {\n        offset[yAxis.orientation] += yAxis.width;\n      }\n      if (legendItem && this.legendInstance) {\n        var legendBox = this.legendInstance.getBBox();\n        offset = appendOffsetOfLegend(offset, items, this.props, legendBox);\n      }\n      return _extends({}, offset, {\n        width: width - offset.left - offset.right,\n        height: height - offset.top - offset.bottom\n      });\n    }\n    /**\n     * Calculate the scale function, position, width, height of axes\n     * @param  {Object} axis     The configuration of axis\n     * @param  {Object} offset   The offset of main part in the svg element\n     * @param  {Object} axisType The type of axis, x-axis or y-axis\n     * @return {Object} Configuration\n     */\n  }, {\n    key: 'getFormatAxis',\n    value: function getFormatAxis(axis, offset, axisType) {\n      var orientation = axis.orientation,\n        domain = axis.domain,\n        mirror = axis.mirror,\n        tickFormat = axis.tickFormat,\n        _axis$padding = axis.padding,\n        padding = _axis$padding === undefined ? {} : _axis$padding;\n      var position = {\n        left: offset.left,\n        right: offset.left + offset.width,\n        top: offset.top,\n        bottom: offset.top + offset.height\n      };\n      var range = axisType === 'xAxis' ? [offset.left + (padding.left || 0), offset.left + offset.width - (padding.right || 0)] : [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)];\n      var scale = parseScale(axis).domain(domain).range(range);\n      var ticks = getTicksOfScale(scale, axis);\n      if (tickFormat) {\n        scale.tickFormat(tickFormat);\n      }\n      var x = void 0,\n        y = void 0;\n      if (axisType === 'xAxis') {\n        var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n        x = offset.left;\n        y = position[orientation] - needSpace * axis.height;\n      } else {\n        var _needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n        x = position[orientation] - _needSpace * axis.width;\n        y = offset.top;\n      }\n      return _extends({}, axis, ticks, {\n        scale: scale,\n        width: axisType === 'xAxis' ? offset.width : axis.width,\n        height: axisType === 'yAxis' ? offset.height : axis.height,\n        x: x,\n        y: y\n      });\n    }\n\n    /**\n     * Get the content to be displayed in the tooltip\n     * @param  {Object} data  The data of active item\n     * @param  {Object} xAxis The configuration of x-axis\n     * @param  {Object} yAxis The configuration of y-axis\n     * @param  {Object} zAxis The configuration of z-axis\n     * @return {Array}        The content of tooltip\n     */\n  }, {\n    key: 'getTooltipContent',\n    value: function getTooltipContent(data, xAxis, yAxis, zAxis) {\n      if (!data) {\n        return null;\n      }\n      var payload = data.payload,\n        node = data.node;\n      var content = [{\n        name: xAxis.name || xAxis.dataKey,\n        unit: xAxis.unit || '',\n        value: node.x,\n        payload: payload\n      }, {\n        name: yAxis.name || yAxis.dataKey,\n        unit: yAxis.unit || '',\n        value: node.y,\n        payload: payload\n      }];\n      if (node.z && node.z !== '-') {\n        content.push({\n          name: zAxis.name || zAxis.dataKey,\n          unit: zAxis.unit || '',\n          value: node.z,\n          payload: payload\n        });\n      }\n      return content;\n    }\n    /**\n     * The handler of mouse entering a scatter\n     * @param {Object} el The active scatter\n     * @param {Object} e  Event object\n     * @return {Object} no return\n     */\n\n    /**\n     * The handler of mouse leaving a scatter\n     * @return {Object} no return\n     */\n  }, {\n    key: 'renderTooltip',\n    /**\n     * Draw Tooltip\n     * @param  {Array} items   The instances of Scatter\n     * @param  {Object} xAxis  The configuration of x-axis\n     * @param  {Object} yAxis  The configuration of y-axis\n     * @param  {Object} zAxis  The configuration of z-axis\n     * @param  {Object} offset The offset of main part in the svg element\n     * @return {ReactElement}  The instance of Tooltip\n     */\n    value: function renderTooltip(items, xAxis, yAxis, zAxis, offset) {\n      var children = this.props.children;\n      var tooltipItem = findChildByType(children, Tooltip);\n      if (!tooltipItem) {\n        return null;\n      }\n      var _state = this.state,\n        isTooltipActive = _state.isTooltipActive,\n        activeItem = _state.activeItem,\n        activeTooltipCoord = _state.activeTooltipCoord;\n      var viewBox = {\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height\n      };\n      return React.cloneElement(tooltipItem, {\n        viewBox: viewBox,\n        active: isTooltipActive,\n        label: '',\n        payload: this.getTooltipContent(activeItem, xAxis, yAxis, zAxis),\n        coordinate: activeTooltipCoord\n      });\n    }\n\n    /**\n     * Draw grid\n     * @param  {Object} xAxis  The configuration of x-axis\n     * @param  {Object} yAxis  The configuration of y-axis\n     * @param  {Object} offset The offset of main part in the svg element\n     * @return {ReactElement} The instance of grid\n     */\n  }, {\n    key: 'renderGrid',\n    value: function renderGrid(xAxis, yAxis, offset) {\n      var _props2 = this.props,\n        children = _props2.children,\n        width = _props2.width,\n        height = _props2.height;\n      var gridItem = findChildByType(children, CartesianGrid);\n      if (!gridItem) {\n        return null;\n      }\n      var verticalPoints = getCoordinatesOfGrid(CartesianAxis.getTicks(_extends({}, CartesianAxis.defaultProps, xAxis, {\n        ticks: getTicksOfAxis(xAxis, true),\n        viewBox: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      })), offset.left, offset.left + offset.width);\n      var horizontalPoints = getCoordinatesOfGrid(CartesianAxis.getTicks(_extends({}, CartesianAxis.defaultProps, yAxis, {\n        ticks: getTicksOfAxis(yAxis, true),\n        viewBox: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      })), offset.top, offset.top + offset.height);\n      return React.cloneElement(gridItem, {\n        key: 'grid',\n        x: offset.left,\n        y: offset.top,\n        width: offset.width,\n        height: offset.height,\n        verticalPoints: verticalPoints,\n        horizontalPoints: horizontalPoints\n      });\n    }\n    /**\n     * Draw legend\n     * @param  {Array} items     The instances of Scatters\n     * @return {ReactElement}    The instance of Legend\n     */\n  }, {\n    key: 'renderLegend',\n    value: function renderLegend(items) {\n      var _this2 = this;\n      var _props3 = this.props,\n        children = _props3.children,\n        width = _props3.width,\n        height = _props3.height,\n        margin = _props3.margin;\n      var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n      var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n      var props = getLegendProps(children, items, legendWidth, legendHeight);\n      if (!props) {\n        return null;\n      }\n      return React.createElement(Legend, _extends({}, props, {\n        chartWidth: width,\n        chartHeight: height,\n        margin: margin,\n        ref: function ref(legend) {\n          _this2.legendInstance = legend;\n        },\n        onBBoxUpdate: this.handleLegendBBoxUpdate\n      }));\n    }\n\n    /**\n     * Draw axis\n     * @param {Object} axis     The configuration of axis\n     * @param {String} layerKey The key of layer\n     * @return {ReactElement}   The instance of axis\n     */\n  }, {\n    key: 'renderAxis',\n    value: function renderAxis(axis, layerKey) {\n      var _props4 = this.props,\n        width = _props4.width,\n        height = _props4.height;\n      if (axis && !axis.hide) {\n        return React.createElement(Layer, {\n          key: layerKey,\n          className: layerKey\n        }, React.createElement(CartesianAxis, _extends({}, axis, {\n          viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n          },\n          ticks: getTicksOfAxis(axis, true)\n        })));\n      }\n      return null;\n    }\n  }, {\n    key: 'renderCursor',\n    value: function renderCursor(xAxis, yAxis, offset) {\n      var children = this.props.children;\n      var tooltipItem = findChildByType(children, Tooltip);\n      if (!tooltipItem || !tooltipItem.props.cursor || !this.state.isTooltipActive) {\n        return null;\n      }\n      var activeItem = this.state.activeItem;\n      var cursorProps = _extends({\n        stroke: '#ccc',\n        strokeDasharray: '5 5'\n      }, getPresentationAttributes(tooltipItem.props.cursor), offset, {\n        x: activeItem.cx,\n        y: activeItem.cy,\n        payload: activeItem\n      });\n      return React.isValidElement(tooltipItem.props.cursor) ? React.cloneElement(tooltipItem.props.cursor, cursorProps) : React.createElement(Cross, cursorProps);\n    }\n\n    /**\n     * Draw the main part of scatter chart\n     * @param  {Array} items   All the instance of Scatter\n     * @param  {Object} xAxis  The configuration of all x-axis\n     * @param  {Object} yAxis  The configuration of all y-axis\n     * @param  {Object} zAxis  The configuration of all z-axis\n     * @param  {Object} offset The offset of main part in the svg element\n     * @return {ReactComponent}  All the instances of Scatter\n     */\n  }, {\n    key: 'renderItems',\n    value: function renderItems(items, xAxis, yAxis, zAxis, offset) {\n      var _this3 = this;\n      var activeGroupId = this.state.activeGroupId;\n      return items.map(function (child, i) {\n        var _child$props = child.props,\n          strokeWidth = _child$props.strokeWidth,\n          data = _child$props.data;\n        var finalStrokeWidth = strokeWidth === +strokeWidth ? strokeWidth : 1;\n        finalStrokeWidth = activeGroupId === 'scatter-' + i ? finalStrokeWidth + 2 : finalStrokeWidth;\n        return React.cloneElement(child, _extends({\n          key: child.key || 'scatter-' + i,\n          groupId: 'scatter-' + i,\n          strokeWidth: finalStrokeWidth,\n          onMouseLeave: _this3.handleScatterMouseLeave,\n          onMouseEnter: _this3.handleScatterMouseEnter,\n          points: _this3.getComposedData(child, data, xAxis, yAxis, zAxis)\n        }, offset, {\n          xAxis: xAxis,\n          yAxis: yAxis\n        }));\n      }, this);\n    }\n  }, {\n    key: 'renderReferenceElements',\n    value: function renderReferenceElements(xAxis, yAxis, offset, isFront, Compt) {\n      var children = this.props.children;\n      var elements = findAllByType(children, Compt);\n      if (!elements || !elements.length) {\n        return null;\n      }\n      var keyPrefix = getDisplayName(Compt) + '-' + (isFront ? 'front' : 'back');\n      return elements.filter(function (entry) {\n        return isFront === entry.props.isFront;\n      }).map(function (entry, i) {\n        return React.cloneElement(entry, {\n          key: keyPrefix + '-' + i,\n          xAxis: xAxis,\n          yAxis: yAxis,\n          viewBox: {\n            x: offset.left,\n            y: offset.top,\n            width: offset.width,\n            height: offset.height\n          }\n        });\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      if (!validateWidthHeight(this)) {\n        return null;\n      }\n\n      // eslint-disable-next-line no-unused-vars\n\n      var _props5 = this.props,\n        style = _props5.style,\n        children = _props5.children,\n        className = _props5.className,\n        width = _props5.width,\n        height = _props5.height,\n        others = _objectWithoutProperties(_props5, ['style', 'children', 'className', 'width', 'height']);\n      var items = findAllByType(children, Scatter);\n      var zAxis = this.getZAxis(items);\n      var xAxis = this.getAxis('xAxis', items);\n      var yAxis = this.getAxis('yAxis', items);\n      var offset = this.getOffset(items, xAxis, yAxis);\n      xAxis = this.getFormatAxis(xAxis, offset, 'xAxis');\n      yAxis = this.getFormatAxis(yAxis, offset, 'yAxis');\n      var events = filterEventAttributes(this.props);\n      var attrs = getPresentationAttributes(others);\n      return React.createElement('div', _extends({\n        className: classNames('recharts-wrapper', className),\n        style: {\n          position: 'relative',\n          cursor: 'default',\n          width: width,\n          height: height\n        }\n      }, events), React.createElement(Surface, _extends({}, attrs, {\n        width: width,\n        height: height\n      }), this.renderGrid(xAxis, yAxis, offset), this.renderReferenceElements(xAxis, yAxis, offset, false, ReferenceArea), this.renderReferenceElements(xAxis, yAxis, offset, false, ReferenceLine), this.renderReferenceElements(xAxis, yAxis, offset, false, ReferenceDot), this.renderAxis(xAxis, 'recharts-x-axis'), this.renderAxis(yAxis, 'recharts-y-axis'), this.renderCursor(xAxis, yAxis, offset), this.renderItems(items, xAxis, yAxis, zAxis, offset), this.renderReferenceElements(xAxis, yAxis, offset, true, ReferenceArea), this.renderReferenceElements(xAxis, yAxis, offset, true, ReferenceLine), this.renderReferenceElements(xAxis, yAxis, offset, true, ReferenceDot), filterSvgElements(children)), this.renderLegend(items), this.renderTooltip(items, xAxis, yAxis, zAxis, offset));\n    }\n  }]);\n  return ScatterChart;\n}(Component), _class2.displayName = 'ScatterChart', _class2.propTypes = _extends({}, EVENT_ATTRIBUTES, {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  margin: PropTypes.shape({\n    top: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number,\n    left: PropTypes.number\n  }),\n  title: PropTypes.string,\n  style: PropTypes.object,\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n  className: PropTypes.string\n}), _class2.defaultProps = {\n  style: {},\n  margin: {\n    top: 5,\n    right: 5,\n    bottom: 5,\n    left: 5\n  }\n}, _temp2)) || _class;\nexport default ScatterChart;","map":null,"metadata":{},"sourceType":"module"}