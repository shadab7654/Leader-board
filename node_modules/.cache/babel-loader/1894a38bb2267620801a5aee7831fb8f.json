{"ast":null,"code":"import _isFunction from 'lodash/isFunction';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp2;\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Render a group of radial bar\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Animate from 'react-smooth';\nimport Sector from '../shape/Sector';\nimport Layer from '../container/Layer';\nimport { getStringSize } from '../util/DOMUtils';\nimport { PRESENTATION_ATTRIBUTES, LEGEND_TYPES, getPresentationAttributes, filterEventsOfChild, isSsr } from '../util/ReactUtils';\nimport pureRender from '../util/PureRender';\nimport { polarToCartesian } from '../util/PolarUtils';\nimport { uniqueId, mathSign } from '../util/DataUtils';\nvar RADIAN = Math.PI / 180;\nvar RadialBar = pureRender(_class = (_temp2 = _class2 = function (_Component) {\n  _inherits(RadialBar, _Component);\n  function RadialBar() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, RadialBar);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = RadialBar.__proto__ || Object.getPrototypeOf(RadialBar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      isAnimationFinished: false\n    }, _this.handleAnimationEnd = function () {\n      _this.setState({\n        isAnimationFinished: true\n      });\n    }, _this.handleAnimationStart = function () {\n      _this.setState({\n        isAnimationFinished: false\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(RadialBar, [{\n    key: 'getDeltaAngle',\n    value: function getDeltaAngle() {\n      var _props = this.props,\n        startAngle = _props.startAngle,\n        endAngle = _props.endAngle;\n      var sign = mathSign(endAngle - startAngle);\n      var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);\n      return sign * deltaAngle;\n    }\n  }, {\n    key: 'getSectors',\n    value: function getSectors() {\n      var _props2 = this.props,\n        cx = _props2.cx,\n        cy = _props2.cy,\n        startAngle = _props2.startAngle,\n        data = _props2.data,\n        minAngle = _props2.minAngle,\n        maxAngle = _props2.maxAngle;\n      var maxValue = Math.max.apply(null, data.map(function (entry) {\n        return Math.abs(entry.value);\n      }));\n      var absMinAngle = Math.abs(minAngle);\n      var absMaxAngle = Math.abs(maxAngle);\n      var deltaAngle = this.getDeltaAngle();\n      var gapAngle = Math.min(Math.abs(absMaxAngle - absMinAngle), 360);\n      var sectors = data.map(function (entry) {\n        var value = entry.value;\n        var tempEndAngle = maxValue === 0 ? startAngle : startAngle + mathSign(value * deltaAngle) * (absMinAngle + gapAngle * Math.abs(entry.value) / maxValue);\n        return _extends({}, entry, {\n          cx: cx,\n          cy: cy,\n          startAngle: startAngle,\n          endAngle: tempEndAngle,\n          payload: entry\n        });\n      });\n      return sectors;\n    }\n  }, {\n    key: 'getLabelPathArc',\n    value: function getLabelPathArc(data, labelContent, style) {\n      var label = this.props.label;\n      var labelProps = React.isValidElement(label) ? label.props : label;\n      var offsetRadius = labelProps.offsetRadius || 2;\n      var orientation = labelProps.orientation || 'inner';\n      var cx = data.cx,\n        cy = data.cy,\n        innerRadius = data.innerRadius,\n        outerRadius = data.outerRadius,\n        startAngle = data.startAngle,\n        endAngle = data.endAngle;\n      var clockWise = this.getDeltaAngle() < 0 && data.value > 0;\n      var radius = clockWise ? innerRadius + offsetRadius : Math.max(outerRadius - offsetRadius, 0);\n      if (radius <= 0) {\n        return '';\n      }\n      var labelSize = getStringSize(labelContent, style);\n      var deltaAngle = labelSize.width / (radius * RADIAN);\n      var tempStartAngle = void 0,\n        tempEndAngle = void 0;\n      if (clockWise) {\n        tempStartAngle = orientation === 'inner' ? Math.min(endAngle + deltaAngle, startAngle) : endAngle;\n        tempEndAngle = tempStartAngle - deltaAngle;\n      } else {\n        tempStartAngle = orientation === 'inner' ? Math.max(endAngle - deltaAngle, startAngle) : endAngle;\n        tempEndAngle = tempStartAngle + deltaAngle;\n      }\n      var startPoint = polarToCartesian(cx, cy, radius, tempStartAngle);\n      var endPoint = polarToCartesian(cx, cy, radius, tempEndAngle);\n      return 'M' + startPoint.x + ',' + startPoint.y + '\\n            A' + radius + ',' + radius + ',0,\\n            ' + (deltaAngle >= 180 ? 1 : 0) + ',\\n            ' + (clockWise ? 1 : 0) + ',\\n            ' + endPoint.x + ',' + endPoint.y;\n    }\n  }, {\n    key: 'renderSectorShape',\n    value: function renderSectorShape(shape, props) {\n      var sectorShape = void 0;\n      if (React.isValidElement(shape)) {\n        sectorShape = React.cloneElement(shape, props);\n      } else if (_isFunction(shape)) {\n        sectorShape = shape(props);\n      } else {\n        sectorShape = React.createElement(Sector, props);\n      }\n      return sectorShape;\n    }\n  }, {\n    key: 'renderSectors',\n    value: function renderSectors(sectors) {\n      var _this2 = this;\n      var _props3 = this.props,\n        shape = _props3.shape,\n        activeShape = _props3.activeShape,\n        activeIndex = _props3.activeIndex,\n        cornerRadius = _props3.cornerRadius;\n      var _props4 = this.props,\n        animationEasing = _props4.animationEasing,\n        animationDuration = _props4.animationDuration,\n        animationBegin = _props4.animationBegin,\n        isAnimationActive = _props4.isAnimationActive;\n      var baseProps = getPresentationAttributes(this.props);\n      return sectors.map(function (entry, i) {\n        var startAngle = entry.startAngle,\n          endAngle = entry.endAngle;\n        return React.createElement(Animate, {\n          from: {\n            angle: startAngle\n          },\n          to: {\n            angle: endAngle\n          },\n          begin: animationBegin,\n          isActive: isAnimationActive,\n          duration: animationDuration,\n          easing: animationEasing,\n          shouldReAnimate: true,\n          key: 'aniamte-' + i,\n          onAnimationStart: _this2.handleAnimationStart,\n          onAnimationEnd: _this2.handleAnimationEnd\n        }, function (_ref2) {\n          var angle = _ref2.angle;\n          var props = _extends({}, baseProps, {\n            cornerRadius: cornerRadius\n          }, entry, filterEventsOfChild(_this2.props, entry, i), {\n            endAngle: angle,\n            key: 'sector-' + i,\n            className: 'recharts-radial-bar-sector'\n          });\n          return _this2.renderSectorShape(i === activeIndex ? activeShape : shape, props);\n        });\n      });\n    }\n  }, {\n    key: 'renderBackground',\n    value: function renderBackground(sectors) {\n      var _this3 = this;\n      var _props5 = this.props,\n        startAngle = _props5.startAngle,\n        endAngle = _props5.endAngle,\n        background = _props5.background,\n        cornerRadius = _props5.cornerRadius;\n      var backgroundProps = getPresentationAttributes(background);\n      return sectors.map(function (entry, i) {\n        // eslint-disable-next-line no-unused-vars\n        var value = entry.value,\n          rest = _objectWithoutProperties(entry, ['value']);\n        var props = _extends({\n          cornerRadius: cornerRadius\n        }, rest, {\n          fill: '#eee'\n        }, backgroundProps, filterEventsOfChild(_this3.props, entry, i), {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          index: i,\n          key: 'sector-' + i,\n          className: 'recharts-radial-bar-background-sector'\n        });\n        return _this3.renderSectorShape(background, props);\n      });\n    }\n  }, {\n    key: 'renderLabelItem',\n    value: function renderLabelItem(option, props, value) {\n      var labelItem = void 0;\n      if (React.isValidElement(option)) {\n        labelItem = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        labelItem = option(props);\n      } else {\n        var id = uniqueId('recharts-defs-');\n        var filteredProps = getPresentationAttributes(props);\n        var path = this.getLabelPathArc(props, value, filteredProps);\n        labelItem = React.createElement('text', _extends({}, filteredProps, {\n          key: props.key,\n          className: 'recharts-radial-bar-label'\n        }), React.createElement('defs', null, React.createElement('path', {\n          id: id,\n          d: path\n        })), React.createElement('textPath', {\n          xlinkHref: '#' + id\n        }, value));\n      }\n      return labelItem;\n    }\n  }, {\n    key: 'renderLabels',\n    value: function renderLabels(sectors) {\n      var _this4 = this;\n      var isAnimationActive = this.props.isAnimationActive;\n      if (isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var label = this.props.label;\n      return sectors.map(function (entry, i) {\n        var props = _extends({\n          fontSize: 10\n        }, entry, getPresentationAttributes(label), {\n          index: i,\n          key: 'label-' + i\n        });\n        return _this4.renderLabelItem(label, props, entry.value);\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n        data = _props6.data,\n        className = _props6.className,\n        background = _props6.background,\n        label = _props6.label;\n      if (!data || !data.length) {\n        return null;\n      }\n      var sectors = this.getSectors();\n      var layerClass = classNames('recharts-area', className);\n      return React.createElement(Layer, {\n        className: layerClass\n      }, background && React.createElement(Layer, {\n        className: 'recharts-radial-bar-background'\n      }, this.renderBackground(sectors)), React.createElement(Layer, {\n        className: 'recharts-radial-bar-sectors'\n      }, this.renderSectors(sectors)), label && React.createElement(Layer, {\n        className: 'recharts-radial-bar-labels'\n      }, this.renderLabels(sectors)));\n    }\n  }]);\n  return RadialBar;\n}(Component), _class2.displayName = 'RadialBar', _class2.propTypes = _extends({}, PRESENTATION_ATTRIBUTES, {\n  className: PropTypes.string,\n  shape: PropTypes.oneOfType([PropTypes.func, PropTypes.element]),\n  activeShape: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.element]),\n  activeIndex: PropTypes.number,\n  cornerRadius: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  cx: PropTypes.number,\n  cy: PropTypes.number,\n  startAngle: PropTypes.number,\n  endAngle: PropTypes.number,\n  maxAngle: PropTypes.number,\n  minAngle: PropTypes.number,\n  data: PropTypes.arrayOf(PropTypes.shape({\n    cx: PropTypes.number,\n    cy: PropTypes.number,\n    innerRadius: PropTypes.number,\n    outerRadius: PropTypes.number,\n    value: PropTypes.value\n  })),\n  legendType: PropTypes.oneOf(LEGEND_TYPES),\n  label: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.element, PropTypes.object]),\n  background: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object, PropTypes.element]),\n  onMouseEnter: PropTypes.func,\n  onMouseLeave: PropTypes.func,\n  onClick: PropTypes.func,\n  isAnimationActive: PropTypes.bool,\n  animationBegin: PropTypes.number,\n  animationDuration: PropTypes.number,\n  animationEasing: PropTypes.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear', 'spring'])\n}), _class2.defaultProps = {\n  startAngle: 180,\n  endAngle: 0,\n  maxAngle: 135,\n  minAngle: 0,\n  legendType: 'rect',\n  data: [],\n  isAnimationActive: !isSsr(),\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease'\n}, _temp2)) || _class;\nexport default RadialBar;","map":null,"metadata":{},"sourceType":"module"}