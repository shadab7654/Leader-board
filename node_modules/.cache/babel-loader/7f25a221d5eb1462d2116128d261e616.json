{"ast":null,"code":"import _isNil from 'lodash/isNil';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { shallowEqual } from './PureRender';\nimport { getDisplayName, findAllByType } from './ReactUtils';\nimport { getStackedDataOfItem, getTicksOfAxis, getBarSizeList, getBarPosition } from './CartesianUtils';\nimport { getBandSizeOfAxis } from './DataUtils';\n\n/*\n * ComposedDataDecorator is a wrapper component that calculates expensive,\n * reusable data like ticks of an axis, stores it in state on this component,\n * and passes it in as props to the wrapped component.\n */\nexport default (function (_ref) {\n  var getComposedData = _ref.getComposedData,\n    ChildComponent = _ref.ChildComponent;\n  return function (WrappedComponent) {\n    var _class, _temp2;\n    return _temp2 = _class = function (_Component) {\n      _inherits(ComposedDataDecorator, _Component);\n      function ComposedDataDecorator() {\n        var _ref2;\n        var _temp, _this, _ret;\n        _classCallCheck(this, ComposedDataDecorator);\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = ComposedDataDecorator.__proto__ || Object.getPrototypeOf(ComposedDataDecorator)).call.apply(_ref2, [this].concat(args))), _this), _this.state = _this.calculateExpensiveState({\n          props: _this.props\n        }), _temp), _possibleConstructorReturn(_this, _ret);\n      }\n\n      // static WrappedComponent = WrappedComponent;\n\n      _createClass(ComposedDataDecorator, [{\n        key: 'calculateExpensiveState',\n        /**\n         * @param {Object} props The props object to operate on\n         * @return {Object} returnObj\n         *  returnObj {Array} axisTicks Used by renderCursor and anything\n         *          else that needs the ticks of the axisTicks\n         *  returObj {Array} allComposedData An array or arrays.\n         *          Each top-level element is the composedData {points, baseLine, layout}\n         *          for a given child(graphcalItem) of the overall Chart\n         */\n        value: function calculateExpensiveState(_ref3) {\n          var props = _ref3.props;\n          var children = props.children,\n            graphicalItems = props.graphicalItems,\n            xAxisMap = props.xAxisMap,\n            yAxisMap = props.yAxisMap,\n            stackGroups = props.stackGroups,\n            layout = props.layout,\n            offset = props.offset,\n            barSize = props.barSize,\n            barGap = props.barGap,\n            barCategoryGap = props.barCategoryGap,\n            globalMaxBarSize = props.maxBarSize;\n\n          // Some charts pre-filter their items into the graphicalItems prop,\n          // others filter it in render of the children\n\n          var items = graphicalItems || findAllByType(children, ChildComponent);\n          var sizeList = getBarSizeList({\n            barSize: barSize,\n            stackGroups: stackGroups\n          });\n          var axisTicks = void 0;\n          var allComposedData = [];\n          items.forEach(function (item) {\n            var _item$props = item.props,\n              xAxisId = _item$props.xAxisId,\n              yAxisId = _item$props.yAxisId,\n              dataKey = _item$props.dataKey,\n              childMaxBarSize = _item$props.maxBarSize;\n            var xAxis = void 0,\n              yAxis = void 0,\n              xTicks = void 0,\n              yTicks = void 0,\n              barPosition = void 0,\n              stackedData = void 0,\n              bandSize = void 0;\n            if (xAxisMap || yAxisMap) {\n              xAxis = xAxisMap[xAxisId];\n              yAxis = yAxisMap[yAxisId];\n              xTicks = getTicksOfAxis(xAxis);\n              yTicks = getTicksOfAxis(yAxis);\n\n              // axisTicks is more global - only need to set once\n              axisTicks = axisTicks || (layout === 'horizontal' ? xTicks : yTicks);\n              var numericAxisId = layout === 'horizontal' ? yAxisId : xAxisId;\n              var cateAxisId = layout === 'horizontal' ? xAxisId : yAxisId;\n              var cateAxis = layout === 'horizontal' ? xAxis : yAxis;\n              var cateTicks = layout === 'horizontal' ? xTicks : yTicks;\n              stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);\n              bandSize = getBandSizeOfAxis(cateAxis, cateTicks);\n              var maxBarSize = _isNil(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;\n              barPosition = getBarPosition({\n                barGap: barGap,\n                barCategoryGap: barCategoryGap,\n                bandSize: bandSize,\n                sizeList: sizeList[cateAxisId],\n                maxBarSize: maxBarSize\n              });\n            }\n            var composedData = getComposedData && getComposedData({\n              props: props,\n              xAxis: xAxis,\n              yAxis: yAxis,\n              xTicks: xTicks,\n              yTicks: yTicks,\n              dataKey: dataKey,\n              item: item,\n              bandSize: bandSize,\n              barPosition: barPosition,\n              offset: offset,\n              stackedData: stackedData\n            }) || {};\n            allComposedData.push(composedData);\n          });\n          return {\n            axisTicks: axisTicks,\n            allComposedData: allComposedData\n          };\n        }\n        /*\n        * Update the state of the composedData if anything relevant changed\n        */\n        /* eslint-disable no-unused-vars */\n      }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n          var graphicalItems = nextProps.graphicalItems,\n            children = nextProps.children,\n            chartX = nextProps.chartX,\n            chartY = nextProps.chartY,\n            activeTooltipIndex = nextProps.activeTooltipIndex,\n            activeLabel = nextProps.activeLabel,\n            activeCoordinate = nextProps.activeCoordinate,\n            activePayload = nextProps.activePayload,\n            isTooltipActive = nextProps.isTooltipActive,\n            restNextProps = _objectWithoutProperties(nextProps, ['graphicalItems', 'children', 'chartX', 'chartY', 'activeTooltipIndex', 'activeLabel', 'activeCoordinate', 'activePayload', 'isTooltipActive']);\n          var _props = this.props,\n            graphicalItemsOld = _props.graphicalItems,\n            childrenOld = _props.children,\n            chartXOld = _props.chartX,\n            chartYOld = _props.chartY,\n            aTIOld = _props.activeTooltipIndex,\n            aLOld = _props.activeLabel,\n            aCOld = _props.activeCoordinate,\n            aPOld = _props.activePayload,\n            iTAOld = _props.isTooltipActive,\n            restOldProps = _objectWithoutProperties(_props, ['graphicalItems', 'children', 'chartX', 'chartY', 'activeTooltipIndex', 'activeLabel', 'activeCoordinate', 'activePayload', 'isTooltipActive']);\n\n          /* eslint-enable no-unused-vars */\n\n          if (!shallowEqual(graphicalItems, graphicalItemsOld) || !shallowEqual(children, childrenOld) || !shallowEqual(restNextProps, restOldProps)) {\n            this.setState(this.calculateExpensiveState({\n              props: nextProps\n            }));\n          }\n        }\n        /*\n         * Ignore the state generated by calculateExpensiveState when determining\n         * whether to update\n         */\n      }, {\n        key: 'shouldComponentUpdate',\n        value: function shouldComponentUpdate(_ref4, nextState) {\n          var graphicalItems = _ref4.graphicalItems,\n            restProps = _objectWithoutProperties(_ref4, ['graphicalItems']);\n\n          // props.graphicalItems is sometimes generated every time -\n          // check that specially as object equality is likely to fail\n          var _props2 = this.props,\n            graphicalItemsOld = _props2.graphicalItems,\n            restPropsOld = _objectWithoutProperties(_props2, ['graphicalItems']);\n          return !shallowEqual(graphicalItems, graphicalItemsOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);\n        }\n      }, {\n        key: 'render',\n        value: function render() {\n          return React.createElement(WrappedComponent, _extends({}, this.props, this.state));\n        }\n      }]);\n      return ComposedDataDecorator;\n    }(Component), _class.displayName = 'ComposedDataDecorator(' + getDisplayName(WrappedComponent) + ')', _class.propTypes = _extends({}, WrappedComponent.propTypes, {\n      chartX: PropTypes.number,\n      chartY: PropTypes.number,\n      data: PropTypes.array\n    }), _class.defaultProps = WrappedComponent.defaultProps, _temp2;\n  };\n});","map":null,"metadata":{},"sourceType":"module"}