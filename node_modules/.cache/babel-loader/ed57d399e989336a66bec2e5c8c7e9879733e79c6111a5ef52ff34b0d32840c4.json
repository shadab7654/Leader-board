{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTickValuesFixedDomain = exports.getTickValues = exports.getNiceTickValues = undefined;\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}(); /**\n      * @fileOverview calculate tick values of scale\n      * @author xile611, arcthur\n      * @date 2015-09-17\n      */\n\nvar _utils = require('./util/utils');\nvar _arithmetic = require('./util/arithmetic');\nvar _arithmetic2 = _interopRequireDefault(_arithmetic);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    min = _ref2[0],\n    max = _ref2[1];\n  var validMin = min,\n    validMax = max;\n\n  // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n  return [validMin, validMax];\n}\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Number}  roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Number}  The step which is easy to understand between two ticks\n */\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep <= 0) {\n    return 0;\n  }\n  var digitCount = _arithmetic2.default.getDigitCount(roughStep);\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var stepRatio = roughStep / Math.pow(10, digitCount);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var amendStepRatio = digitCount !== 1 ? _arithmetic2.default.multiply(Math.ceil(stepRatio / 0.05) + correctionFactor, 0.05) : _arithmetic2.default.multiply(Math.ceil(stepRatio / 0.1) + correctionFactor, 0.1);\n  var formatStep = _arithmetic2.default.multiply(amendStepRatio, Math.pow(10, digitCount));\n  return allowDecimals ? formatStep : Math.ceil(formatStep);\n}\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var isFlt = _arithmetic2.default.isFloat(value);\n  var step = 1;\n  // calculate the middle value of ticks\n  var middle = value;\n  if (isFlt && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = Math.pow(10, _arithmetic2.default.getDigitCount(value) - 1);\n      middle = _arithmetic2.default.multiply(Math.floor(value / step), step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = Math.floor(value);\n    }\n  } else if (value === 0) {\n    middle = Math.floor((tickCount - 1) / 2);\n  } else if (!allowDecimals) {\n    middle = Math.floor(value);\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(n - middleIndex, step));\n  }), _utils.range);\n  return fn(0, tickCount);\n}\n\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep((max - min) / (tickCount - 1), allowDecimals, correctionFactor);\n  // A medial value of ticks\n  var middle = void 0;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = 0;\n  } else {\n    middle = _arithmetic2.default.divide(_arithmetic2.default.sum(min, max), 2);\n    middle = _arithmetic2.default.minus(middle, _arithmetic2.default.modulo(middle, step));\n  }\n  var belowCount = Math.ceil((middle - min) / step);\n  var upCount = Math.ceil((max - middle) / step);\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  } else if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step: step,\n    tickMin: _arithmetic2.default.minus(middle, _arithmetic2.default.multiply(belowCount, step)),\n    tickMax: _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(upCount, step))\n  };\n}\n/**\n * Calculate the ticks of an interval\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n    min = _ref4[0],\n    max = _ref4[1];\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var _getValidInterval = getValidInterval([min, max]),\n    _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n    cormin = _getValidInterval2[0],\n    cormax = _getValidInterval2[1];\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n    step = _calculateStep.step,\n    tickMin = _calculateStep.tickMin,\n    tickMax = _calculateStep.tickMax;\n  var values = _arithmetic2.default.rangeStep(tickMin, tickMax + 0.1 * step, step);\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n    min = _ref6[0],\n    max = _ref6[1];\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var _getValidInterval3 = getValidInterval([min, max]),\n    _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n    cormin = _getValidInterval4[0],\n    cormax = _getValidInterval4[1];\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n  var step = getFormatStep((cormax - cormin) / (count - 1), allowDecimals, 0);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return cormin + n * step;\n  }), _utils.range);\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n    min = _ref8[0],\n    max = _ref8[1];\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var _getValidInterval5 = getValidInterval([min, max]),\n    _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n    cormin = _getValidInterval6[0],\n    cormax = _getValidInterval6[1];\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep((cormax - cormin) / (count - 1), allowDecimals, 0);\n  var values = [].concat(_toConsumableArray(_arithmetic2.default.rangeStep(cormin, cormax - 0.99 * step, step)), [cormax]);\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\nvar getNiceTickValues = exports.getNiceTickValues = (0, _utils.memoize)(getNiceTickValuesFn);\nvar getTickValues = exports.getTickValues = (0, _utils.memoize)(getTickValuesFn);\nvar getTickValuesFixedDomain = exports.getTickValuesFixedDomain = (0, _utils.memoize)(getTickValuesFixedDomainFn);","map":{"version":3,"names":["Object","defineProperty","exports","value","getTickValuesFixedDomain","getTickValues","getNiceTickValues","undefined","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_utils","require","_arithmetic","_arithmetic2","_interopRequireDefault","obj","__esModule","default","_toConsumableArray","arr2","from","getValidInterval","_ref","_ref2","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","digitCount","getDigitCount","stepRatio","Math","pow","amendStepRatio","multiply","ceil","formatStep","getTickOfSingleValue","tickCount","isFlt","isFloat","step","middle","absVal","abs","floor","middleIndex","fn","compose","map","n","sum","range","calculateStep","arguments","divide","minus","modulo","belowCount","upCount","scaleCount","tickMin","tickMax","getNiceTickValuesFn","_ref3","_ref4","count","_getValidInterval","_getValidInterval2","cormin","cormax","_calculateStep","values","rangeStep","reverse","getTickValuesFn","_ref5","_ref6","_getValidInterval3","_getValidInterval4","filter","entry","getTickValuesFixedDomainFn","_ref7","_ref8","_getValidInterval5","_getValidInterval6","concat","memoize"],"sources":["/home/alam/Desktop/ReactProject/leaderboard/node_modules/recharts-scale/lib/getNiceTickValues.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTickValuesFixedDomain = exports.getTickValues = exports.getNiceTickValues = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileOverview calculate tick values of scale\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author xile611, arcthur\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @date 2015-09-17\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nvar _utils = require('./util/utils');\n\nvar _arithmetic = require('./util/arithmetic');\n\nvar _arithmetic2 = _interopRequireDefault(_arithmetic);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  var validMin = min,\n      validMax = max;\n\n  // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n\n  return [validMin, validMax];\n}\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Number}  roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Number}  The step which is easy to understand between two ticks\n */\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep <= 0) {\n    return 0;\n  }\n\n  var digitCount = _arithmetic2.default.getDigitCount(roughStep);\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var stepRatio = roughStep / Math.pow(10, digitCount);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var amendStepRatio = digitCount !== 1 ? _arithmetic2.default.multiply(Math.ceil(stepRatio / 0.05) + correctionFactor, 0.05) : _arithmetic2.default.multiply(Math.ceil(stepRatio / 0.1) + correctionFactor, 0.1);\n\n  var formatStep = _arithmetic2.default.multiply(amendStepRatio, Math.pow(10, digitCount));\n\n  return allowDecimals ? formatStep : Math.ceil(formatStep);\n}\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var isFlt = _arithmetic2.default.isFloat(value);\n  var step = 1;\n  // calculate the middle value of ticks\n  var middle = value;\n\n  if (isFlt && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = Math.pow(10, _arithmetic2.default.getDigitCount(value) - 1);\n\n      middle = _arithmetic2.default.multiply(Math.floor(value / step), step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = Math.floor(value);\n    }\n  } else if (value === 0) {\n    middle = Math.floor((tickCount - 1) / 2);\n  } else if (!allowDecimals) {\n    middle = Math.floor(value);\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(n - middleIndex, step));\n  }), _utils.range);\n\n  return fn(0, tickCount);\n}\n\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep((max - min) / (tickCount - 1), allowDecimals, correctionFactor);\n  // A medial value of ticks\n  var middle = void 0;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = 0;\n  } else {\n    middle = _arithmetic2.default.divide(_arithmetic2.default.sum(min, max), 2);\n    middle = _arithmetic2.default.minus(middle, _arithmetic2.default.modulo(middle, step));\n  }\n\n  var belowCount = Math.ceil((middle - min) / step);\n  var upCount = Math.ceil((max - middle) / step);\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  } else if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step: step,\n    tickMin: _arithmetic2.default.minus(middle, _arithmetic2.default.multiply(belowCount, step)),\n    tickMax: _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(upCount, step))\n  };\n}\n/**\n * Calculate the ticks of an interval\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      min = _ref4[0],\n      max = _ref4[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval = getValidInterval([min, max]),\n      _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n      cormin = _getValidInterval2[0],\n      cormax = _getValidInterval2[1];\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n      step = _calculateStep.step,\n      tickMin = _calculateStep.tickMin,\n      tickMax = _calculateStep.tickMax;\n\n  var values = _arithmetic2.default.rangeStep(tickMin, tickMax + 0.1 * step, step);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval3 = getValidInterval([min, max]),\n      _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n      cormin = _getValidInterval4[0],\n      cormax = _getValidInterval4[1];\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  var step = getFormatStep((cormax - cormin) / (count - 1), allowDecimals, 0);\n\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return cormin + n * step;\n  }), _utils.range);\n\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      min = _ref8[0],\n      max = _ref8[1];\n\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var _getValidInterval5 = getValidInterval([min, max]),\n      _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n      cormin = _getValidInterval6[0],\n      cormax = _getValidInterval6[1];\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep((cormax - cormin) / (count - 1), allowDecimals, 0);\n  var values = [].concat(_toConsumableArray(_arithmetic2.default.rangeStep(cormin, cormax - 0.99 * step, step)), [cormax]);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n\nvar getNiceTickValues = exports.getNiceTickValues = (0, _utils.memoize)(getNiceTickValuesFn);\nvar getTickValues = exports.getTickValues = (0, _utils.memoize)(getTickValuesFn);\nvar getTickValuesFixedDomain = exports.getTickValuesFixedDomain = (0, _utils.memoize)(getTickValuesFixedDomainFn);"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}