{"ast":null,"code":"import _isArray from 'lodash/isArray';\nimport _isNil from 'lodash/isNil';\nimport _isFunction from 'lodash/isFunction';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp2;\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Render a group of bar\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Animate, { translateStyle } from 'react-smooth';\nimport Rectangle from '../shape/Rectangle';\nimport Layer from '../container/Layer';\nimport Text from '../component/Text';\nimport ErrorBar from './ErrorBar';\nimport pureRender from '../util/PureRender';\nimport { getValueByDataKey, uniqueId } from '../util/DataUtils';\nimport { PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, LEGEND_TYPES, getPresentationAttributes, filterEventsOfChild, isSsr, findChildByType } from '../util/ReactUtils';\nvar Bar = pureRender(_class = (_temp2 = _class2 = function (_Component) {\n  _inherits(Bar, _Component);\n  function Bar() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, Bar);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Bar.__proto__ || Object.getPrototypeOf(Bar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      isAnimationFinished: false\n    }, _this.id = uniqueId('recharts-bar-'), _this.handleAnimationEnd = function () {\n      _this.setState({\n        isAnimationFinished: true\n      });\n      _this.props.onAnimationEnd();\n    }, _this.handleAnimationStart = function () {\n      _this.setState({\n        isAnimationFinished: false\n      });\n      _this.props.onAnimationStart();\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(Bar, [{\n    key: 'renderRectangle',\n    value: function renderRectangle(option, props) {\n      var rectangle = void 0;\n      if (React.isValidElement(option)) {\n        rectangle = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        rectangle = option(props);\n      } else {\n        rectangle = React.createElement(Rectangle, props);\n      }\n      return rectangle;\n    }\n  }, {\n    key: 'renderRectangles',\n    value: function renderRectangles() {\n      var _this2 = this;\n      var _props = this.props,\n        data = _props.data,\n        shape = _props.shape,\n        layout = _props.layout,\n        isAnimationActive = _props.isAnimationActive,\n        animationBegin = _props.animationBegin,\n        animationDuration = _props.animationDuration,\n        animationEasing = _props.animationEasing,\n        animationId = _props.animationId;\n      var baseProps = getPresentationAttributes(this.props);\n      var getStyle = function getStyle(isBegin) {\n        return {\n          transform: 'scale' + (layout === 'vertical' ? 'X' : 'Y') + '(' + (isBegin ? 0 : 1) + ')'\n        };\n      };\n      return data.map(function (entry, index) {\n        var x = entry.x,\n          y = entry.y,\n          width = entry.width,\n          height = entry.height;\n        var props = _extends({}, baseProps, entry, {\n          index: index\n        });\n        if (_isNil(entry.value) || !isAnimationActive) {\n          return React.createElement(Layer, _extends({\n            className: 'recharts-bar-rectangle'\n          }, filterEventsOfChild(_this2.props, entry, index), {\n            key: 'rectangle-' + index\n          }), _this2.renderRectangle(shape, props));\n        }\n        var transformOrigin = '';\n        if (layout === 'vertical') {\n          transformOrigin = x + 'px ' + (y + height / 2) + 'px';\n        } else {\n          transformOrigin = x + width / 2 + 'px ' + (y + height) + 'px';\n        }\n        return React.createElement(Animate, {\n          begin: animationBegin,\n          duration: animationDuration,\n          isActive: isAnimationActive,\n          easing: animationEasing,\n          from: getStyle(true),\n          to: getStyle(false),\n          key: 'rectangle-' + index + '-' + animationId,\n          onAnimationEnd: _this2.handleAnimationEnd,\n          onAnimationStart: _this2.handleAnimationStart\n        }, React.createElement(Layer, _extends({\n          className: 'recharts-bar-rectangle',\n          style: translateStyle({\n            transformOrigin: transformOrigin\n          })\n        }, filterEventsOfChild(_this2.props, entry, index), {\n          key: 'rectangle-' + index\n        }), _this2.renderRectangle(shape, props)));\n      });\n    }\n  }, {\n    key: 'renderLabelItem',\n    value: function renderLabelItem(option, props, value) {\n      var labelItem = null;\n      if (React.isValidElement(option)) {\n        labelItem = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        labelItem = option(props);\n      } else {\n        labelItem = React.createElement(Text, _extends({}, props, {\n          key: props.key,\n          className: 'recharts-bar-label'\n        }), _isArray(value) ? value[1] : value);\n      }\n      return labelItem;\n    }\n  }, {\n    key: 'renderLabels',\n    value: function renderLabels() {\n      var _this3 = this;\n      var isAnimationActive = this.props.isAnimationActive;\n      if (isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props2 = this.props,\n        data = _props2.data,\n        label = _props2.label,\n        layout = _props2.layout;\n      var barProps = getPresentationAttributes(this.props);\n      var customLabelProps = getPresentationAttributes(label);\n      var labels = data.map(function (entry, i) {\n        var textAnchor = 'middle';\n        var dominantBaseline = 'central';\n        var x = 0;\n        var y = 0;\n        if (layout === 'vertical') {\n          textAnchor = entry.width < 0 ? 'end' : 'start';\n          x = entry.x + entry.width + (entry.width < 0 ? -1 : 1) * 5;\n          y = entry.y + entry.height / 2;\n        } else {\n          dominantBaseline = entry.height < 0 ? 'hanging' : 'inherit';\n          x = entry.x + entry.width / 2;\n          y = entry.y - (entry.height < 0 ? -1 : 1) * 5;\n        }\n        var labelProps = _extends({\n          dominantBaseline: dominantBaseline,\n          textAnchor: textAnchor\n        }, barProps, entry, customLabelProps, {\n          x: x,\n          y: y,\n          index: i,\n          key: 'label-' + i,\n          payload: entry.payload\n        });\n        var labelValue = entry.value;\n        if (label === true && entry.value && labelProps.label) {\n          labelValue = labelProps.label;\n        }\n        return _this3.renderLabelItem(label, labelProps, labelValue);\n      });\n      return React.createElement(Layer, {\n        className: 'recharts-bar-labels'\n      }, labels);\n    }\n  }, {\n    key: 'renderErrorBar',\n    value: function renderErrorBar() {\n      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props3 = this.props,\n        data = _props3.data,\n        xAxis = _props3.xAxis,\n        yAxis = _props3.yAxis,\n        layout = _props3.layout,\n        children = _props3.children;\n      var errorBarItem = findChildByType(children, ErrorBar);\n      if (!errorBarItem) {\n        return null;\n      }\n      var offset = layout === 'vertical' ? data[0].height / 2 : data[0].width / 2;\n      function dataPointFormatter(dataPoint, dataKey) {\n        return {\n          x: dataPoint.x,\n          y: dataPoint.y,\n          value: dataPoint.value,\n          errorVal: getValueByDataKey(dataPoint, dataKey)\n        };\n      }\n      return React.cloneElement(errorBarItem, {\n        data: data,\n        xAxis: xAxis,\n        yAxis: yAxis,\n        layout: layout,\n        offset: offset,\n        dataPointFormatter: dataPointFormatter\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props4 = this.props,\n        data = _props4.data,\n        className = _props4.className,\n        label = _props4.label,\n        xAxis = _props4.xAxis,\n        yAxis = _props4.yAxis,\n        left = _props4.left,\n        top = _props4.top,\n        width = _props4.width,\n        height = _props4.height;\n      if (!data || !data.length) {\n        return null;\n      }\n      var layerClass = classNames('recharts-bar', className);\n      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;\n      return React.createElement(Layer, {\n        className: layerClass\n      }, needClip ? React.createElement('defs', null, React.createElement('clipPath', {\n        id: 'clipPath-' + this.id\n      }, React.createElement('rect', {\n        x: left,\n        y: top,\n        width: width,\n        height: height\n      }))) : null, React.createElement(Layer, {\n        className: 'recharts-bar-rectangles',\n        clipPath: needClip ? 'url(#clipPath-' + this.id + ')' : null\n      }, this.renderRectangles()), label && React.createElement(Layer, {\n        className: 'recharts-bar-rectangle-labels'\n      }, this.renderLabels()), this.renderErrorBar());\n    }\n  }]);\n  return Bar;\n}(Component), _class2.displayName = 'Bar', _class2.propTypes = _extends({}, PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, {\n  className: PropTypes.string,\n  layout: PropTypes.oneOf(['vertical', 'horizontal']),\n  xAxisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  yAxisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  yAxis: PropTypes.object,\n  xAxis: PropTypes.object,\n  stackId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  barSize: PropTypes.number,\n  unit: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  name: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  dataKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.func]).isRequired,\n  legendType: PropTypes.oneOf(LEGEND_TYPES),\n  minPointSize: PropTypes.number,\n  maxBarSize: PropTypes.number,\n  shape: PropTypes.oneOfType([PropTypes.func, PropTypes.element]),\n  label: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object, PropTypes.element]),\n  data: PropTypes.arrayOf(PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    radius: PropTypes.oneOfType([PropTypes.number, PropTypes.array]),\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.array])\n  })),\n  onAnimationStart: PropTypes.func,\n  onAnimationEnd: PropTypes.func,\n  animationId: PropTypes.number,\n  isAnimationActive: PropTypes.bool,\n  animationBegin: PropTypes.number,\n  animationDuration: PropTypes.number,\n  animationEasing: PropTypes.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear'])\n}), _class2.defaultProps = {\n  xAxisId: 0,\n  yAxisId: 0,\n  legendType: 'rect',\n  minPointSize: 0,\n  // data of bar\n  data: [],\n  layout: 'vertical',\n  isAnimationActive: !isSsr(),\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  onAnimationStart: function onAnimationStart() {},\n  onAnimationEnd: function onAnimationEnd() {}\n}, _temp2)) || _class;\nexport default Bar;","map":null,"metadata":{},"sourceType":"module"}