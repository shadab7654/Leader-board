{"ast":null,"code":"import _isNil from 'lodash/isNil';\nimport _isArray from 'lodash/isArray';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { findAllByType, findChildByType } from './ReactUtils';\nimport { getPercentValue, isNumber, isNumOrStr, getValueByDataKey, uniqueId } from './DataUtils';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport Legend from '../component/Legend';\n\n/* eslint no-param-reassign: 0 */\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\nexport var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType) {\n  var lines = findAllByType(children, ReferenceLine);\n  var dots = findAllByType(children, ReferenceDot);\n  var elements = lines.concat(dots);\n  var areas = findAllByType(children, ReferenceArea);\n  var idKey = axisType + 'Id';\n  var valueKey = axisType[0];\n  var finalDomain = domain;\n  if (elements.length) {\n    finalDomain = elements.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && el.props.alwaysShow && isNumber(el.props[valueKey])) {\n        var value = el.props[valueKey];\n        return [Math.min(result[0], value), Math.max(result[1], value)];\n      }\n      return result;\n    }, finalDomain);\n  }\n  if (areas.length) {\n    (function () {\n      var key1 = valueKey + '1';\n      var key2 = valueKey + '2';\n      finalDomain = areas.reduce(function (result, el) {\n        if (el.props[idKey] === axisId && el.props.alwaysShow && isNumber(el.props[key1]) && isNumber(el.props[key2])) {\n          var value1 = el.props[key1];\n          var value2 = el.props[key2];\n          return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];\n        }\n        return result;\n      }, finalDomain);\n    })();\n  }\n  return finalDomain;\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, items, numericAxisId, cateAxisId, offsetType) {\n  var stackGroups = items.reduce(function (result, item) {\n    var stackId = item.props.stackId;\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items = [item].concat(childGroup.items);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _extends({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _extends({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n    return _extends({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group && group.items.length) {\n      var itemIndex = -1;\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [Math.min.apply(null, ticks), Math.max.apply(null, ticks)];\n  }\n  return ticks;\n};\n\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = data.reduce(function (result, entry) {\n    var value = getValueByDataKey(entry, key);\n    if (_isArray(value)) {\n      return [].concat(_toConsumableArray(result), _toConsumableArray(value));\n    }\n    return [].concat(_toConsumableArray(result), [value]);\n  }, []);\n  if (type === 'number') {\n    var domain = flattenData.filter(isNumber);\n    return [Math.min.apply(null, domain), Math.max.apply(null, domain)];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [Math.min.apply(null, entry.concat([result[0]]).filter(isNumber)), Math.max.apply(null, entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\n\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    return getDomainOfDataByKey(data, item.props.dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {};\n  // Get the union set of category axis\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis';\n};\n/**\n* Calculate the Coordinates of grid\n* @param  {Array} ticks The ticks in axis\n* @param {Number} min   The minimun value of axis\n* @param {Number} max   The maximun value of axis\n* @return {Array}       Coordinates\n*/\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin = void 0,\n    hasMax = void 0;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n  return values;\n};\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n\n  // The ticks setted by user should only affect the ticks adjacent to axis line\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry\n      };\n    });\n  }\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry\n      };\n    });\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index\n    };\n  });\n};\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks) {\n  var index = -1;\n  var len = ticks.length;\n  if (len > 1) {\n    for (var i = 0; i < len; i++) {\n      if (i === 0 && coordinate <= (ticks[i].coordinate + ticks[i + 1].coordinate) / 2 || i > 0 && i < len - 1 && coordinate > (ticks[i].coordinate + ticks[i - 1].coordinate) / 2 && coordinate <= (ticks[i].coordinate + ticks[i + 1].coordinate) / 2 || i === len - 1 && coordinate > (ticks[i].coordinate + ticks[i - 1].coordinate) / 2) {\n        index = ticks[i].index;\n        break;\n      }\n    }\n  } else {\n    index = 0;\n  }\n  return index;\n};\n\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var result = void 0;\n  switch (displayName) {\n    case 'Line':\n    case 'Area':\n      result = item.props.stroke;\n      break;\n    default:\n      result = item.props.fill;\n      break;\n  }\n  return result;\n};\nexport var getLegendProps = function getLegendProps(children, graphicItems, width) {\n  var legendItem = findChildByType(children, Legend);\n  if (!legendItem) {\n    return null;\n  }\n  var legendData = legendItem.props && legendItem.props.payload || graphicItems.map(function (child) {\n    var _child$props = child.props,\n      dataKey = _child$props.dataKey,\n      name = _child$props.name,\n      legendType = _child$props.legendType;\n    return {\n      dataKey: dataKey,\n      type: legendItem.props.iconType || legendType || 'square',\n      color: getMainColorOfGraphicItem(child),\n      value: name || dataKey,\n      payload: child.props\n    };\n  });\n  return _extends({}, legendItem.props, Legend.getWithHeight(legendItem, width), {\n    payload: legendData\n  });\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  if (opts.scale !== 'auto' && opts.scale !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  } else if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\n\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\nexport var getBarSizeList = function getBarSizeList(_ref) {\n  var globalSize = _ref.barSize,\n    _ref$stackGroups = _ref.stackGroups,\n    stackGroups = _ref$stackGroups === undefined ? {} : _ref$stackGroups;\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return item.type.displayName === 'Bar';\n      });\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n  return result;\n};\n\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\nexport var getBarPosition = function getBarPosition(_ref2) {\n  var barGap = _ref2.barGap,\n    barCategoryGap = _ref2.barCategoryGap,\n    bandSize = _ref2.bandSize,\n    _ref2$sizeList = _ref2.sizeList,\n    sizeList = _ref2$sizeList === undefined ? [] : _ref2$sizeList,\n    maxBarSize = _ref2.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result = void 0;\n\n  // whether or not is barSize setted by user\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    (function () {\n      var useFull = false;\n      var fullBarSize = bandSize / len;\n      var sum = sizeList.reduce(function (res, entry) {\n        return res + entry.barSize || 0;\n      }, 0);\n      sum += (len - 1) * realBarGap;\n      if (sum >= bandSize) {\n        sum -= (len - 1) * realBarGap;\n        realBarGap = 0;\n      }\n      if (sum >= bandSize && fullBarSize > 0) {\n        useFull = true;\n        fullBarSize *= 0.9;\n        sum = len * fullBarSize;\n      }\n      var offset = (bandSize - sum) / 2 >> 0;\n      var prev = {\n        offset: offset - realBarGap,\n        size: 0\n      };\n      result = sizeList.reduce(function (res, entry) {\n        var newRes = [].concat(_toConsumableArray(res), [{\n          item: entry.item,\n          position: {\n            offset: prev.offset + prev.size + realBarGap,\n            size: useFull ? fullBarSize : entry.barSize\n          }\n        }]);\n        prev = newRes[newRes.length - 1].position;\n        if (entry.stackList && entry.stackList.length) {\n          entry.stackList.forEach(function (item) {\n            newRes.push({\n              item: item,\n              position: prev\n            });\n          });\n        }\n        return newRes;\n      }, []);\n    })();\n  } else {\n    (function () {\n      var offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n      if (bandSize - 2 * offset - (len - 1) * realBarGap <= 0) {\n        realBarGap = 0;\n      }\n      var originalSize = (bandSize - 2 * offset - (len - 1) * realBarGap) / len;\n      if (originalSize > 1) {\n        originalSize >>= 0;\n      }\n      var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n      result = sizeList.reduce(function (res, entry, i) {\n        var newRes = [].concat(_toConsumableArray(res), [{\n          item: entry.item,\n          position: {\n            offset: offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n            size: size\n          }\n        }]);\n        if (entry.stackList && entry.stackList.length) {\n          entry.stackList.forEach(function (item) {\n            newRes.push({\n              item: item,\n              position: newRes[newRes.length - 1].position\n            });\n          });\n        }\n        return newRes;\n      }, []);\n    })();\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    height = props.height,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps(children, items, legendWidth, legendHeight);\n  var newOffset = offset;\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _extends({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _extends({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n  return newOffset;\n};","map":{"version":3,"names":["_isNil","_isArray","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_toConsumableArray","arr","Array","isArray","arr2","from","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","getNiceTickValues","getTickValuesFixedDomain","stack","shapeStack","stackOrderNone","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","findAllByType","findChildByType","getPercentValue","isNumber","isNumOrStr","getValueByDataKey","uniqueId","ReferenceDot","ReferenceLine","ReferenceArea","Legend","offsetSign","series","n","j","m","positive","negative","isNaN","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","detectReferenceElementsDomain","children","domain","axisId","axisType","lines","dots","elements","concat","areas","idKey","valueKey","finalDomain","reduce","result","el","props","alwaysShow","Math","min","max","key1","key2","value1","value2","getStackedData","data","stackItems","offsetType","dataKeys","map","item","dataKey","keys","d","order","offset","getStackGroupsByAxisId","items","numericAxisId","cateAxisId","stackGroups","stackId","parentGroup","hasStack","childGroup","group","res","g","stackedData","getStackedDataOfItem","itemIndex","len","calculateDomainOfTicks","ticks","type","apply","getDomainOfDataByKey","filterNil","flattenData","entry","filter","validateData","getDomainOfSingle","Infinity","getDomainOfStackGroups","startIndex","endIndex","s","slice","getDomainOfItemsWithSameAxis","domains","tag","push","isCategorialAxis","layout","getCoordinatesOfGrid","hasMin","hasMax","values","coordinate","getTicksOfAxis","axis","isGrid","isAll","scale","duplicateDomain","bandwidth","niceTicks","scaleContent","indexOf","isCategorial","categoricalDomain","index","tickCount","calculateActiveTickIndex","getMainColorOfGraphicItem","displayName","stroke","fill","getLegendProps","graphicItems","width","legendItem","legendData","payload","child","_child$props","name","legendType","iconType","color","getWithHeight","getTicksOfScale","opts","originalDomain","allowDecimals","tickValues","_domain","_tickValues","getBarSizeList","_ref","globalSize","barSize","_ref$stackGroups","undefined","numericAxisIds","sgs","stackIds","sLen","_sgs$stackIds$j","barItems","selfSize","cateId","stackList","getBarPosition","_ref2","barGap","barCategoryGap","bandSize","_ref2$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","prev","size","newRes","position","forEach","originalSize","appendOffsetOfLegend","legendBox","height","margin","legendWidth","left","right","legendHeight","top","bottom","legendProps","newOffset","box","align","verticalAlign"],"sources":["/home/alam/Desktop/ReactProject/leaderboard/node_modules/recharts/es6/util/CartesianUtils.js"],"sourcesContent":["import _isNil from 'lodash/isNil';\nimport _isArray from 'lodash/isArray';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\n\nimport { findAllByType, findChildByType } from './ReactUtils';\nimport { getPercentValue, isNumber, isNumOrStr, getValueByDataKey, uniqueId } from './DataUtils';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport Legend from '../component/Legend';\n\n/* eslint no-param-reassign: 0 */\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n    }\n  }\n};\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\n\nexport var detectReferenceElementsDomain = function detectReferenceElementsDomain(children, domain, axisId, axisType) {\n  var lines = findAllByType(children, ReferenceLine);\n  var dots = findAllByType(children, ReferenceDot);\n  var elements = lines.concat(dots);\n  var areas = findAllByType(children, ReferenceArea);\n  var idKey = axisType + 'Id';\n  var valueKey = axisType[0];\n  var finalDomain = domain;\n\n  if (elements.length) {\n    finalDomain = elements.reduce(function (result, el) {\n      if (el.props[idKey] === axisId && el.props.alwaysShow && isNumber(el.props[valueKey])) {\n        var value = el.props[valueKey];\n\n        return [Math.min(result[0], value), Math.max(result[1], value)];\n      }\n      return result;\n    }, finalDomain);\n  }\n\n  if (areas.length) {\n    (function () {\n      var key1 = valueKey + '1';\n      var key2 = valueKey + '2';\n\n      finalDomain = areas.reduce(function (result, el) {\n        if (el.props[idKey] === axisId && el.props.alwaysShow && isNumber(el.props[key1]) && isNumber(el.props[key2])) {\n          var value1 = el.props[key1];\n          var value2 = el.props[key2];\n\n          return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];\n        }\n        return result;\n      }, finalDomain);\n    })();\n  }\n\n  return finalDomain;\n};\n\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n\n  return stack(data);\n};\n\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, items, numericAxisId, cateAxisId, offsetType) {\n  var stackGroups = items.reduce(function (result, item) {\n    var stackId = item.props.stackId;\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || { hasStack: false, stackGroups: {} };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId, cateAxisId: cateAxisId, items: []\n      };\n\n      childGroup.items = [item].concat(childGroup.items);\n\n      parentGroup.hasStack = true;\n\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId, cateAxisId: cateAxisId, items: [item]\n      };\n    }\n\n    return _extends({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n\n        return _extends({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _extends({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\n\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [Math.min.apply(null, ticks), Math.max.apply(null, ticks)];\n  }\n\n  return ticks;\n};\n\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = data.reduce(function (result, entry) {\n    var value = getValueByDataKey(entry, key);\n\n    if (_isArray(value)) {\n      return [].concat(_toConsumableArray(result), _toConsumableArray(value));\n    }\n\n    return [].concat(_toConsumableArray(result), [value]);\n  }, []);\n\n  if (type === 'number') {\n    var domain = flattenData.filter(isNumber);\n\n    return [Math.min.apply(null, domain), Math.max.apply(null, domain)];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [Math.min.apply(null, entry.concat([result[0]]).filter(isNumber)), Math.max.apply(null, entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\n\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    return getDomainOfDataByKey(data, item.props.dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {};\n  // Get the union set of category axis\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\n\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis';\n};\n/**\n* Calculate the Coordinates of grid\n* @param  {Array} ticks The ticks in axis\n* @param {Number} min   The minimun value of axis\n* @param {Number} max   The maximun value of axis\n* @return {Array}       Coordinates\n*/\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin = void 0,\n      hasMax = void 0;\n\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type;\n\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n\n  // The ticks setted by user should only affect the ticks adjacent to axis line\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry\n      };\n    });\n  }\n\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return { coordinate: scale(entry) + offset, value: entry };\n    });\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index\n    };\n  });\n};\n\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks) {\n  var index = -1;\n  var len = ticks.length;\n\n  if (len > 1) {\n    for (var i = 0; i < len; i++) {\n      if (i === 0 && coordinate <= (ticks[i].coordinate + ticks[i + 1].coordinate) / 2 || i > 0 && i < len - 1 && coordinate > (ticks[i].coordinate + ticks[i - 1].coordinate) / 2 && coordinate <= (ticks[i].coordinate + ticks[i + 1].coordinate) / 2 || i === len - 1 && coordinate > (ticks[i].coordinate + ticks[i - 1].coordinate) / 2) {\n        index = ticks[i].index;\n        break;\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var result = void 0;\n\n  switch (displayName) {\n    case 'Line':\n    case 'Area':\n      result = item.props.stroke;\n      break;\n    default:\n      result = item.props.fill;\n      break;\n  }\n\n  return result;\n};\n\nexport var getLegendProps = function getLegendProps(children, graphicItems, width) {\n  var legendItem = findChildByType(children, Legend);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData = legendItem.props && legendItem.props.payload || graphicItems.map(function (child) {\n    var _child$props = child.props,\n        dataKey = _child$props.dataKey,\n        name = _child$props.name,\n        legendType = _child$props.legendType;\n\n\n    return {\n      dataKey: dataKey,\n      type: legendItem.props.iconType || legendType || 'square',\n      color: getMainColorOfGraphicItem(child),\n      value: name || dataKey,\n      payload: child.props\n    };\n  });\n\n  return _extends({}, legendItem.props, Legend.getWithHeight(legendItem, width), {\n    payload: legendData\n  });\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n\n\n  if (opts.scale !== 'auto' && opts.scale !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n\n    return { niceTicks: tickValues };\n  } else if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return { niceTicks: _tickValues };\n  }\n\n  return null;\n};\n\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\nexport var getBarSizeList = function getBarSizeList(_ref) {\n  var globalSize = _ref.barSize,\n      _ref$stackGroups = _ref.stackGroups,\n      stackGroups = _ref$stackGroups === undefined ? {} : _ref$stackGroups;\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n\n\n      var barItems = items.filter(function (item) {\n        return item.type.displayName === 'Bar';\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\nexport var getBarPosition = function getBarPosition(_ref2) {\n  var barGap = _ref2.barGap,\n      barCategoryGap = _ref2.barCategoryGap,\n      bandSize = _ref2.bandSize,\n      _ref2$sizeList = _ref2.sizeList,\n      sizeList = _ref2$sizeList === undefined ? [] : _ref2$sizeList,\n      maxBarSize = _ref2.maxBarSize;\n\n  var len = sizeList.length;\n  if (len < 1) return null;\n\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result = void 0;\n\n  // whether or not is barSize setted by user\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    (function () {\n      var useFull = false;\n      var fullBarSize = bandSize / len;\n      var sum = sizeList.reduce(function (res, entry) {\n        return res + entry.barSize || 0;\n      }, 0);\n      sum += (len - 1) * realBarGap;\n\n      if (sum >= bandSize) {\n        sum -= (len - 1) * realBarGap;\n        realBarGap = 0;\n      }\n      if (sum >= bandSize && fullBarSize > 0) {\n        useFull = true;\n        fullBarSize *= 0.9;\n        sum = len * fullBarSize;\n      }\n\n      var offset = (bandSize - sum) / 2 >> 0;\n      var prev = { offset: offset - realBarGap, size: 0 };\n\n      result = sizeList.reduce(function (res, entry) {\n        var newRes = [].concat(_toConsumableArray(res), [{\n          item: entry.item,\n          position: {\n            offset: prev.offset + prev.size + realBarGap,\n            size: useFull ? fullBarSize : entry.barSize\n          }\n        }]);\n\n        prev = newRes[newRes.length - 1].position;\n\n        if (entry.stackList && entry.stackList.length) {\n          entry.stackList.forEach(function (item) {\n            newRes.push({ item: item, position: prev });\n          });\n        }\n        return newRes;\n      }, []);\n    })();\n  } else {\n    (function () {\n      var offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n      if (bandSize - 2 * offset - (len - 1) * realBarGap <= 0) {\n        realBarGap = 0;\n      }\n\n      var originalSize = (bandSize - 2 * offset - (len - 1) * realBarGap) / len;\n      if (originalSize > 1) {\n        originalSize >>= 0;\n      }\n      var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n\n      result = sizeList.reduce(function (res, entry, i) {\n        var newRes = [].concat(_toConsumableArray(res), [{\n          item: entry.item,\n          position: {\n            offset: offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n            size: size\n          }\n        }]);\n\n        if (entry.stackList && entry.stackList.length) {\n          entry.stackList.forEach(function (item) {\n            newRes.push({ item: item, position: newRes[newRes.length - 1].position });\n          });\n        }\n        return newRes;\n      }, []);\n    })();\n  }\n\n  return result;\n};\n\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      height = props.height,\n      margin = props.margin;\n\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps(children, items, legendWidth, legendHeight);\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _extends({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _extends({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}