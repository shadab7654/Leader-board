{"ast":null,"code":"import _isFunction from 'lodash/isFunction';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp;\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Reference Line\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport pureRender from '../util/PureRender';\nimport Layer from '../container/Layer';\nimport Text from '../component/Text';\nimport { PRESENTATION_ATTRIBUTES } from '../util/ReactUtils';\nimport { validateCoordinateInRange, isNumOrStr } from '../util/DataUtils';\nimport Rectangle from '../shape/Rectangle';\nvar ReferenceArea = pureRender(_class = (_temp = _class2 = function (_Component) {\n  _inherits(ReferenceArea, _Component);\n  function ReferenceArea() {\n    _classCallCheck(this, ReferenceArea);\n    return _possibleConstructorReturn(this, (ReferenceArea.__proto__ || Object.getPrototypeOf(ReferenceArea)).apply(this, arguments));\n  }\n  _createClass(ReferenceArea, [{\n    key: 'getRect',\n    value: function getRect(hasX, hasY) {\n      var _props = this.props,\n        xValue1 = _props.x1,\n        xValue2 = _props.x2,\n        yValue1 = _props.y1,\n        yValue2 = _props.y2,\n        xAxis = _props.xAxis,\n        yAxis = _props.yAxis;\n      var xScale = xAxis.scale;\n      var yScale = yAxis.scale;\n      var xOffset = xScale.bandwidth ? xScale.bandwidth() / 2 : 0;\n      var yOffset = yScale.bandwidth ? yScale.bandwidth() / 2 : 0;\n      var xRange = xScale.range();\n      var yRange = yScale.range();\n      var x1 = void 0,\n        x2 = void 0,\n        y1 = void 0,\n        y2 = void 0;\n      if (hasX && isNumOrStr(xValue1)) {\n        x1 = xScale(xValue1) + xOffset;\n      } else if (hasY) {\n        x1 = xRange[0];\n      }\n      if (hasX && isNumOrStr(xValue2)) {\n        x2 = xScale(xValue2) + xOffset;\n      } else if (hasY) {\n        x2 = xRange[1];\n      }\n      if (hasY && isNumOrStr(yValue1)) {\n        y1 = yScale(yValue1) + yOffset;\n      } else if (hasX) {\n        y1 = yRange[0];\n      }\n      if (hasY && isNumOrStr(yValue2)) {\n        y2 = yScale(yValue2) + yOffset;\n      } else if (hasX) {\n        y2 = yRange[1];\n      }\n      if (validateCoordinateInRange(x1, xScale) && validateCoordinateInRange(x2, xScale) && validateCoordinateInRange(y1, yScale) && validateCoordinateInRange(y2, yScale)) {\n        return {\n          x: Math.min(x1, x2),\n          y: Math.min(y1, y2),\n          width: Math.abs(x2 - x1),\n          height: Math.abs(y2 - y1)\n        };\n      }\n      return null;\n    }\n  }, {\n    key: 'renderLabel',\n    value: function renderLabel(_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        width = _ref.width,\n        height = _ref.height;\n      var _props2 = this.props,\n        label = _props2.label,\n        stroke = _props2.stroke;\n      var props = _extends({}, label, {\n        stroke: 'none',\n        fill: stroke,\n        x: x + width / 2,\n        y: y + height / 2,\n        textAnchor: 'middle'\n      });\n      if (React.isValidElement(label)) {\n        return React.cloneElement(label, props);\n      } else if (_isFunction(label)) {\n        return label(props);\n      } else if (isNumOrStr(label)) {\n        return React.createElement('g', {\n          className: 'recharts-reference-area-label'\n        }, React.createElement(Text, props, label));\n      }\n      return null;\n    }\n  }, {\n    key: 'renderRect',\n    value: function renderRect(option, props) {\n      var rect = void 0;\n      if (React.isValidElement(option)) {\n        rect = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        rect = option(props);\n      } else {\n        rect = React.createElement(Rectangle, _extends({}, props, {\n          className: 'recharts-reference-area-rect'\n        }));\n      }\n      return rect;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n        x1 = _props3.x1,\n        x2 = _props3.x2,\n        y1 = _props3.y1,\n        y2 = _props3.y2;\n      var hasX = isNumOrStr(x1) && isNumOrStr(x2);\n      var hasY = isNumOrStr(y1) && isNumOrStr(y2);\n      if (!hasX && !hasY) {\n        return null;\n      }\n      var rect = this.getRect(hasX, hasY);\n      if (!rect) {\n        return null;\n      }\n      var shape = this.props.shape;\n      return React.createElement(Layer, {\n        className: 'recharts-reference-area'\n      }, this.renderRect(shape, _extends({}, this.props, rect)), this.renderLabel(rect));\n    }\n  }]);\n  return ReferenceArea;\n}(Component), _class2.displayName = 'ReferenceArea', _class2.propTypes = _extends({}, PRESENTATION_ATTRIBUTES, {\n  viewBox: PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number,\n    width: PropTypes.number,\n    height: PropTypes.number\n  }),\n  label: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.func, PropTypes.element]),\n  xAxis: PropTypes.object,\n  yAxis: PropTypes.object,\n  isFront: PropTypes.bool,\n  alwaysShow: PropTypes.bool,\n  x1: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  x2: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  y1: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  y2: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  yAxisId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  xAxisId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  shape: PropTypes.oneOfType([PropTypes.func, PropTypes.element])\n}), _class2.defaultProps = {\n  isFront: false,\n  alwaysShow: false,\n  xAxisId: 0,\n  yAxisId: 0,\n  r: 10,\n  fill: '#ccc',\n  fillOpacity: 0.5,\n  stroke: 'none',\n  strokeWidth: 1\n}, _temp)) || _class;\nexport default ReferenceArea;","map":null,"metadata":{},"sourceType":"module"}