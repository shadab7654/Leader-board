{"ast":null,"code":"import _sortBy from 'lodash/sortBy';\nimport _isFunction from 'lodash/isFunction';\nimport _range from 'lodash/range';\nimport _isNil from 'lodash/isNil';\nimport _throttle from 'lodash/throttle';\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Surface from '../container/Surface';\nimport Layer from '../container/Layer';\nimport Tooltip from '../component/Tooltip';\nimport Legend from '../component/Legend';\nimport { warn } from '../util/LogUtils';\nimport { findAllByType, findChildByType, filterSvgElements, getDisplayName, getPresentationAttributes, validateWidthHeight, isChildrenEqual } from '../util/ReactUtils';\nimport CartesianAxis from '../cartesian/CartesianAxis';\nimport CartesianGrid from '../cartesian/CartesianGrid';\nimport ReferenceLine from '../cartesian/ReferenceLine';\nimport ReferenceDot from '../cartesian/ReferenceDot';\nimport ReferenceArea from '../cartesian/ReferenceArea';\nimport XAxis from '../cartesian/XAxis';\nimport YAxis from '../cartesian/YAxis';\nimport Brush from '../cartesian/Brush';\nimport { getOffset, calculateChartCoordinate } from '../util/DOMUtils';\nimport { parseSpecifiedDomain, getAnyElementOfObject, hasDuplicate, checkDomainOfScale, combineEventHandlers, parseScale, getValueByDataKey, uniqueId } from '../util/DataUtils';\nimport { calculateActiveTickIndex, detectReferenceElementsDomain, getMainColorOfGraphicItem, getDomainOfStackGroups, getDomainOfDataByKey, getLegendProps, getDomainOfItemsWithSameAxis, getCoordinatesOfGrid, getStackGroupsByAxisId, getTicksOfAxis, isCategorialAxis, getTicksOfScale, appendOffsetOfLegend } from '../util/CartesianUtils';\nimport { shallowEqual } from '../util/PureRender';\nimport { eventCenter, SYNC_EVENT } from '../util/Events';\nvar ORIENT_MAP = {\n  xAxis: ['bottom', 'top'],\n  yAxis: ['left', 'right']\n};\nvar originCoordinate = {\n  x: 0,\n  y: 0\n};\nvar generateCategoricalChart = function generateCategoricalChart(ChartComponent, GraphicalChild) {\n  var _class, _temp;\n  var CategoricalChartWrapper = (_temp = _class = function (_Component) {\n    _inherits(CategoricalChartWrapper, _Component);\n    function CategoricalChartWrapper(props) {\n      _classCallCheck(this, CategoricalChartWrapper);\n      var _this = _possibleConstructorReturn(this, (CategoricalChartWrapper.__proto__ || Object.getPrototypeOf(CategoricalChartWrapper)).call(this, props));\n      _this.handleLegendBBoxUpdate = function (box) {\n        if (box && _this.legendInstance) {\n          var _this$state = _this.state,\n            dataStartIndex = _this$state.dataStartIndex,\n            dataEndIndex = _this$state.dataEndIndex;\n          _this.setState(_this.updateStateOfAxisMapsOffsetAndStackGroups({\n            props: _this.props,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n          }));\n        }\n      };\n      _this.handleReceiveSyncEvent = function (cId, chartId, data) {\n        var _this$props = _this.props,\n          syncId = _this$props.syncId,\n          layout = _this$props.layout;\n        if (syncId === cId && chartId !== _this.uniqueChartId) {\n          var dataStartIndex = data.dataStartIndex,\n            dataEndIndex = data.dataEndIndex;\n          if (!_isNil(data.dataStartIndex) || !_isNil(data.dataEndIndex)) {\n            _this.setState(_extends({\n              dataStartIndex: dataStartIndex,\n              dataEndIndex: dataEndIndex\n            }, _this.updateStateOfAxisMapsOffsetAndStackGroups({\n              props: _this.props,\n              dataStartIndex: dataStartIndex,\n              dataEndIndex: dataEndIndex\n            })));\n          } else if (!_isNil(data.activeTooltipIndex)) {\n            var chartX = data.chartX,\n              chartY = data.chartY,\n              activeTooltipIndex = data.activeTooltipIndex;\n            var _this$state2 = _this.state,\n              offset = _this$state2.offset,\n              tooltipTicks = _this$state2.tooltipTicks;\n            if (!offset) {\n              return;\n            }\n            var viewBox = _extends({}, offset, {\n              x: offset.left,\n              y: offset.top\n            });\n            // When a categotical chart is combined with another chart, the value of chartX\n            // and chartY may beyond the boundaries.\n            var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);\n            var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);\n            var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;\n            var activePayload = _this.getTooltipContent(activeTooltipIndex);\n            var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {\n              x: layout === 'horizontal' ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,\n              y: layout === 'horizontal' ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate\n            } : originCoordinate;\n            _this.setState(_extends({}, data, {\n              activeLabel: activeLabel,\n              activeCoordinate: activeCoordinate,\n              activePayload: activePayload\n            }));\n          } else {\n            _this.setState(data);\n          }\n        }\n      };\n      _this.handleBrushChange = function (_ref) {\n        var startIndex = _ref.startIndex,\n          endIndex = _ref.endIndex;\n\n        // Only trigger changes if the extents of the brush have actually changed\n        if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {\n          _this.setState(_extends({\n            dataStartIndex: startIndex,\n            dataEndIndex: endIndex\n          }, _this.updateStateOfAxisMapsOffsetAndStackGroups({\n            props: _this.props,\n            dataStartIndex: startIndex,\n            dataEndIndex: endIndex\n          })));\n          _this.triggerSyncEvent({\n            dataStartIndex: startIndex,\n            dataEndIndex: endIndex\n          });\n        }\n      };\n      _this.handleMouseEnter = function (e) {\n        var onMouseEnter = _this.props.onMouseEnter;\n        var mouse = _this.getMouseInfo(e);\n        if (mouse) {\n          var nextState = _extends({}, mouse, {\n            isTooltipActive: true\n          });\n          _this.setState(nextState);\n          _this.triggerSyncEvent(nextState);\n          if (_isFunction(onMouseEnter)) {\n            onMouseEnter(nextState, e);\n          }\n        }\n      };\n      _this.triggeredAfterMouseMove = function (e) {\n        var onMouseMove = _this.props.onMouseMove;\n        var mouse = _this.getMouseInfo(e);\n        var nextState = mouse ? _extends({}, mouse, {\n          isTooltipActive: true\n        }) : {\n          isTooltipActive: false\n        };\n        _this.setState(nextState);\n        _this.triggerSyncEvent(nextState);\n        if (_isFunction(onMouseMove)) {\n          onMouseMove(nextState, e);\n        }\n      };\n      _this.handleMouseMove = function (e) {\n        if (e && _isFunction(e.persist)) {\n          e.persist();\n          _this.triggeredAfterMouseMove(e);\n        }\n      };\n      _this.handleMouseLeave = function (e) {\n        var onMouseLeave = _this.props.onMouseLeave;\n        var nextState = {\n          isTooltipActive: false\n        };\n        _this.setState(nextState);\n        _this.triggerSyncEvent(nextState);\n        if (_isFunction(onMouseLeave)) {\n          onMouseLeave(nextState, e);\n        }\n      };\n      _this.handleClick = function (e) {\n        var onClick = _this.props.onClick;\n        if (_isFunction(onClick)) {\n          var mouse = _this.getMouseInfo(e);\n          onClick(mouse, e);\n        }\n      };\n      _this.handleMouseDown = function (e) {\n        var onMouseDown = _this.props.onMouseDown;\n        if (_isFunction(onMouseDown)) {\n          var mouse = _this.getMouseInfo(e);\n          onMouseDown(mouse, e);\n        }\n      };\n      _this.handleMouseUp = function (e) {\n        var onMouseUp = _this.props.onMouseUp;\n        if (_isFunction(onMouseUp)) {\n          var mouse = _this.getMouseInfo(e);\n          onMouseUp(mouse, e);\n        }\n      };\n      _this.handleTouchMove = function (e) {\n        if (e.changedTouches != null && e.changedTouches.length > 0) {\n          _this.handleMouseMove(e.changedTouches[0]);\n        }\n      };\n      _this.verticalCoordinatesGenerator = function (_ref2) {\n        var xAxis = _ref2.xAxis,\n          width = _ref2.width,\n          height = _ref2.height,\n          offset = _ref2.offset;\n        return getCoordinatesOfGrid(CartesianAxis.getTicks(_extends({}, CartesianAxis.defaultProps, xAxis, {\n          ticks: getTicksOfAxis(xAxis, true),\n          viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n          }\n        })), offset.left, offset.left + offset.width);\n      };\n      _this.horizontalCoordinatesGenerator = function (_ref3) {\n        var yAxis = _ref3.yAxis,\n          width = _ref3.width,\n          height = _ref3.height,\n          offset = _ref3.offset;\n        return getCoordinatesOfGrid(CartesianAxis.getTicks(_extends({}, CartesianAxis.defaultProps, yAxis, {\n          ticks: getTicksOfAxis(yAxis, true),\n          viewBox: {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n          }\n        })), offset.top, offset.top + offset.height);\n      };\n      _this.axesTicksGenerator = function (axis) {\n        return getTicksOfAxis(axis, true);\n      };\n      _this.tooltipTicksGenerator = function (_ref4) {\n        var layout = _ref4.layout,\n          xAxisMap = _ref4.xAxisMap,\n          yAxisMap = _ref4.yAxisMap;\n        var axisMap = layout === 'horizontal' ? xAxisMap : yAxisMap;\n        var axis = getAnyElementOfObject(axisMap);\n        var tooltipTicks = getTicksOfAxis(axis, false, true);\n        return {\n          tooltipTicks: tooltipTicks,\n          orderedTooltipTicks: _sortBy(tooltipTicks, function (o) {\n            return o.coordinate;\n          }),\n          tooltipAxis: axis\n        };\n      };\n      var defaultState = _this.createDefaultState(props);\n      _this.state = _extends({}, defaultState, {\n        updateId: 0\n      }, _this.updateStateOfAxisMapsOffsetAndStackGroups(_extends({\n        props: props\n      }, defaultState)));\n      _this.validateAxes();\n      _this.uniqueChartId = uniqueId('recharts');\n      if (props.throttleDelay) {\n        _this.triggeredAfterMouseMove = _throttle(_this.triggeredAfterMouseMove, props.throttleDelay);\n      }\n      return _this;\n    }\n\n    /* eslint-disable  react/no-did-mount-set-state */\n\n    _createClass(CategoricalChartWrapper, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (!_isNil(this.props.syncId)) {\n          this.addListener();\n        }\n      }\n    }, {\n      key: 'componentWillReceiveProps',\n      value: function componentWillReceiveProps(nextProps) {\n        var _props = this.props,\n          data = _props.data,\n          children = _props.children,\n          width = _props.width,\n          height = _props.height,\n          layout = _props.layout,\n          stackOffset = _props.stackOffset,\n          margin = _props.margin;\n        if (nextProps.data !== data || nextProps.width !== width || nextProps.height !== height || nextProps.layout !== layout || nextProps.stackOffset !== stackOffset || !shallowEqual(nextProps.margin, margin)) {\n          var defaultState = this.createDefaultState(nextProps);\n          this.setState(_extends({}, defaultState, {\n            updateId: this.state.updateId + 1\n          }, this.updateStateOfAxisMapsOffsetAndStackGroups(_extends({\n            props: nextProps\n          }, defaultState))));\n        } else if (!isChildrenEqual(nextProps.children, children)) {\n          var _state = this.state,\n            dataStartIndex = _state.dataStartIndex,\n            dataEndIndex = _state.dataEndIndex;\n          // Don't update brush\n\n          var _defaultState = _extends({}, this.createDefaultState(nextProps), {\n            dataEndIndex: dataEndIndex,\n            dataStartIndex: dataStartIndex\n          });\n          this.setState(_extends({}, _defaultState, this.updateStateOfAxisMapsOffsetAndStackGroups(_extends({\n            props: nextProps\n          }, _defaultState))));\n        }\n        // add syncId\n        if (_isNil(this.props.syncId) && !_isNil(nextProps.syncId)) {\n          this.addListener();\n        }\n        // remove syncId\n        if (!_isNil(this.props.syncId) && _isNil(nextProps.syncId)) {\n          this.removeListener();\n        }\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (!_isNil(this.props.syncId)) {\n          this.removeListener();\n        }\n        if (typeof this.triggeredAfterMouseMove.cancel === 'function') {\n          this.triggeredAfterMouseMove.cancel();\n        }\n      }\n      /**\n      * Get the configuration of all x-axis or y-axis\n      * @param  {Object} props          Latest props\n      * @param  {String} axisType       The type of axis\n      * @param  {Array}  graphicalItems The instances of item\n      * @param  {Object} stackGroups    The items grouped by axisId and stackId\n      * @param {Number} dataStartIndex  The start index of the data series when a brush is applied\n      * @param {Number} dataEndIndex    The end index of the data series when a brush is applied\n      * @return {Object}          Configuration\n      */\n    }, {\n      key: 'getAxisMap',\n      value: function getAxisMap(props, _ref5) {\n        var _ref5$axisType = _ref5.axisType,\n          axisType = _ref5$axisType === undefined ? 'xAxis' : _ref5$axisType,\n          graphicalItems = _ref5.graphicalItems,\n          stackGroups = _ref5.stackGroups,\n          dataStartIndex = _ref5.dataStartIndex,\n          dataEndIndex = _ref5.dataEndIndex;\n        var children = props.children;\n        var Axis = axisType === 'xAxis' ? XAxis : YAxis;\n        var axisIdKey = axisType === 'xAxis' ? 'xAxisId' : 'yAxisId';\n        // Get all the instance of Axis\n        var axes = findAllByType(children, Axis);\n        var axisMap = {};\n        if (axes && axes.length) {\n          axisMap = this.getAxisMapByAxes(props, {\n            axes: axes,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n          });\n        } else if (graphicalItems && graphicalItems.length) {\n          axisMap = this.getAxisMapByItems(props, {\n            graphicalItems: graphicalItems,\n            Axis: Axis,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n          });\n        }\n        return axisMap;\n      }\n\n      /**\n       * Get the configuration of axis by the options of axis instance\n       * @param  {Object} props         Latest props\n       * @param {Array}  axes           The instance of axes\n       * @param  {Array} graphicalItems The instances of item\n       * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n       * @param  {String} axisIdKey     The unique id of an axis\n       * @param  {Object} stackGroups   The items grouped by axisId and stackId\n       * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n       * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n       * @return {Object}      Configuration\n       */\n    }, {\n      key: 'getAxisMapByAxes',\n      value: function getAxisMapByAxes(props, _ref6) {\n        var axes = _ref6.axes,\n          graphicalItems = _ref6.graphicalItems,\n          axisType = _ref6.axisType,\n          axisIdKey = _ref6.axisIdKey,\n          stackGroups = _ref6.stackGroups,\n          dataStartIndex = _ref6.dataStartIndex,\n          dataEndIndex = _ref6.dataEndIndex;\n        var layout = props.layout,\n          children = props.children,\n          data = props.data,\n          stackOffset = props.stackOffset;\n        var displayedData = data.slice(dataStartIndex, dataEndIndex + 1);\n        var len = displayedData.length;\n        var isCategorial = isCategorialAxis(layout, axisType);\n\n        // Eliminate duplicated axes\n        var axisMap = axes.reduce(function (result, child) {\n          var _child$props = child.props,\n            type = _child$props.type,\n            dataKey = _child$props.dataKey,\n            allowDataOverflow = _child$props.allowDataOverflow,\n            scale = _child$props.scale;\n          var axisId = child.props[axisIdKey];\n          if (!result[axisId]) {\n            var domain = void 0,\n              duplicateDomain = void 0,\n              categoricalDomain = void 0;\n            if (dataKey) {\n              domain = getDomainOfDataByKey(displayedData, dataKey, type);\n              if (type === 'category' && isCategorial) {\n                var duplicate = hasDuplicate(domain);\n                duplicateDomain = duplicate ? domain : null;\n\n                // When category axis has duplicated text, serial numbers are used to generate scale\n                domain = duplicate ? _range(0, len) : domain;\n              } else if (type === 'category') {\n                // eliminate undefined or null or empty string\n                domain = domain.filter(function (entry) {\n                  return entry !== '' && !_isNil(entry);\n                });\n              }\n              if (isCategorial && (type === 'number' || scale !== 'auto')) {\n                categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, 'category');\n              }\n            } else if (isCategorial) {\n              domain = _range(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === 'number') {\n              // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]\n              domain = stackOffset === 'expand' ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n            } else {\n              domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (entry) {\n                return entry.props[axisIdKey] === axisId;\n              }), type, true);\n            }\n            if (type === 'number') {\n              // To detect wether there is any reference lines whose props alwaysShow is true\n              domain = detectReferenceElementsDomain(children, domain, axisId, axisType);\n              if (child.props.domain) {\n                domain = parseSpecifiedDomain(child.props.domain, domain, allowDataOverflow);\n              }\n            }\n            return _extends({}, result, _defineProperty({}, axisId, _extends({}, child.props, {\n              axisType: axisType,\n              domain: domain,\n              categoricalDomain: categoricalDomain,\n              duplicateDomain: duplicateDomain,\n              originalDomain: child.props.domain,\n              isCategorial: isCategorial\n            })));\n          }\n          return result;\n        }, {});\n        return axisMap;\n      }\n\n      /**\n       * Get the configuration of axis by the options of item,\n       * this kind of axis does not display in chart\n       * @param  {Object} props         Latest props\n       * @param  {Array} graphicalItems The instances of item\n       * @param  {ReactElement} Axis    Axis Component\n       * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n       * @param  {String} axisIdKey     The unique id of an axis\n       * @param  {Object} stackGroups   The items grouped by axisId and stackId\n       * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n       * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n       * @return {Object}               Configuration\n       */\n    }, {\n      key: 'getAxisMapByItems',\n      value: function getAxisMapByItems(props, _ref7) {\n        var graphicalItems = _ref7.graphicalItems,\n          Axis = _ref7.Axis,\n          axisType = _ref7.axisType,\n          axisIdKey = _ref7.axisIdKey,\n          stackGroups = _ref7.stackGroups,\n          dataStartIndex = _ref7.dataStartIndex,\n          dataEndIndex = _ref7.dataEndIndex;\n        var layout = props.layout,\n          children = props.children,\n          data = props.data;\n        var displayedData = data.slice(dataStartIndex, dataEndIndex + 1);\n        var len = displayedData.length;\n        var isCategorial = isCategorialAxis(layout, axisType);\n        var index = -1;\n\n        // The default type of x-axis is category axis,\n        // The default contents of x-axis is the serial numbers of data\n        // The default type of y-axis is number axis\n        // The default contents of y-axis is the domain of data\n        var axisMap = graphicalItems.reduce(function (result, child) {\n          var axisId = child.props[axisIdKey];\n          if (!result[axisId]) {\n            index++;\n            var domain = void 0;\n            if (isCategorial) {\n              domain = _range(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {\n              domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n              domain = detectReferenceElementsDomain(children, domain, axisId, axisType);\n            } else {\n              domain = parseSpecifiedDomain(Axis.defaultProps.domain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function (entry) {\n                return entry.props[axisIdKey] === axisId;\n              }), 'number'), Axis.defaultProps.allowDataOverflow);\n              domain = detectReferenceElementsDomain(children, domain, axisId, axisType);\n            }\n            return _extends({}, result, _defineProperty({}, axisId, _extends({\n              axisType: axisType\n            }, Axis.defaultProps, {\n              hide: true,\n              orientation: ORIENT_MAP[axisType][index % 2],\n              domain: domain,\n              originalDomain: Axis.defaultProps.domain,\n              isCategorial: isCategorial\n            })));\n          }\n          return result;\n        }, {});\n        return axisMap;\n      }\n      /**\n       * Calculate the scale function, position, width, height of axes\n       * @param  {Object} props    Latest props\n       * @param  {Object} axisMap  The configuration of axes\n       * @param  {Object} offset   The offset of main part in the svg element\n       * @param  {Object} axisType The type of axes, x-axis or y-axis\n       * @return {Object} Configuration\n       */\n    }, {\n      key: 'getFormatAxisMap',\n      value: function getFormatAxisMap(props, axisMap, offset, axisType) {\n        var width = props.width,\n          height = props.height,\n          layout = props.layout;\n        var displayName = this.constructor.displayName;\n        var ids = Object.keys(axisMap);\n        var steps = {\n          left: offset.left,\n          leftMirror: offset.left,\n          right: width - offset.right,\n          rightMirror: width - offset.right,\n          top: offset.top,\n          topMirror: offset.top,\n          bottom: height - offset.bottom,\n          bottomMirror: height - offset.bottom\n        };\n        return ids.reduce(function (result, id) {\n          var axis = axisMap[id];\n          var orientation = axis.orientation,\n            domain = axis.domain,\n            _axis$padding = axis.padding,\n            padding = _axis$padding === undefined ? {} : _axis$padding,\n            mirror = axis.mirror,\n            reversed = axis.reversed;\n          var offsetKey = '' + orientation + (mirror ? 'Mirror' : '');\n          var range = void 0,\n            x = void 0,\n            y = void 0,\n            needSpace = void 0;\n          if (axisType === 'xAxis') {\n            range = [offset.left + (padding.left || 0), offset.left + offset.width - (padding.right || 0)];\n          } else {\n            range = layout === 'horizontal' ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0), offset.top + offset.height - (padding.bottom || 0)];\n          }\n          if (reversed) {\n            range = [range[1], range[0]];\n          }\n          var scale = parseScale(axis, displayName);\n          scale.domain(domain).range(range);\n          checkDomainOfScale(scale);\n          var ticks = getTicksOfScale(scale, axis);\n          if (axisType === 'xAxis') {\n            needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n            x = offset.left;\n            y = steps[offsetKey] - needSpace * axis.height;\n          } else {\n            needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n            x = steps[offsetKey] - needSpace * axis.width;\n            y = offset.top;\n          }\n          var finalAxis = _extends({}, axis, ticks, {\n            range: range,\n            x: x,\n            y: y,\n            scale: scale,\n            width: axisType === 'xAxis' ? offset.width : axis.width,\n            height: axisType === 'yAxis' ? offset.height : axis.height\n          });\n          if (!axis.hide && axisType === 'xAxis') {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;\n          } else if (!axis.hide) {\n            steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;\n          }\n          return _extends({}, result, _defineProperty({}, id, finalAxis));\n        }, {});\n      }\n      /**\n       * Get the information of mouse in chart, return null when the mouse is not in the chart\n       * @param  {Object} event    The event object\n       * @return {Object}          Mouse data\n       */\n    }, {\n      key: 'getMouseInfo',\n      value: function getMouseInfo(event) {\n        if (!this.container) {\n          return null;\n        }\n        var offset = this.state.offset;\n        var containerOffset = getOffset(this.container);\n        var e = calculateChartCoordinate(event, containerOffset);\n        var isIn = e.chartX >= offset.left && e.chartX <= offset.left + offset.width && e.chartY >= offset.top && e.chartY <= offset.top + offset.height;\n        if (!isIn) {\n          return null;\n        }\n        var layout = this.props.layout;\n        var _state2 = this.state,\n          ticks = _state2.orderedTooltipTicks,\n          axis = _state2.tooltipAxis,\n          tooltipTicks = _state2.tooltipTicks;\n        var pos = layout === 'horizontal' ? e.chartX : e.chartY;\n        var activeIndex = calculateActiveTickIndex(pos, ticks, axis);\n        if (activeIndex >= 0) {\n          var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;\n          var activePayload = this.getTooltipContent(activeIndex);\n          var activeCoordinate = tooltipTicks[activeIndex] ? {\n            x: layout === 'horizontal' ? tooltipTicks[activeIndex].coordinate : e.chartX,\n            y: layout === 'horizontal' ? e.chartY : tooltipTicks[activeIndex].coordinate\n          } : originCoordinate;\n          return _extends({}, e, {\n            activeTooltipIndex: activeIndex,\n            activeLabel: activeLabel,\n            activePayload: activePayload,\n            activeCoordinate: activeCoordinate\n          });\n        }\n        return null;\n      }\n      /**\n       * Get the content to be displayed in the tooltip\n       * @param  {Number} activeIndex    Active index of data\n       * @return {Array}                 The content of tooltip\n       */\n    }, {\n      key: 'getTooltipContent',\n      value: function getTooltipContent(activeIndex) {\n        var _state3 = this.state,\n          dataStartIndex = _state3.dataStartIndex,\n          dataEndIndex = _state3.dataEndIndex,\n          graphicalItems = _state3.graphicalItems;\n        var data = this.props.data.slice(dataStartIndex, dataEndIndex + 1);\n        if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= data.length) {\n          return null;\n        }\n        return graphicalItems.map(function (child) {\n          var _child$props2 = child.props,\n            dataKey = _child$props2.dataKey,\n            name = _child$props2.name,\n            unit = _child$props2.unit,\n            formatter = _child$props2.formatter;\n          return _extends({}, getPresentationAttributes(child), {\n            dataKey: dataKey,\n            unit: unit,\n            formatter: formatter,\n            name: name || dataKey,\n            color: getMainColorOfGraphicItem(child),\n            value: getValueByDataKey(data[activeIndex], dataKey),\n            payload: data[activeIndex]\n          });\n        });\n      }\n\n      /**\n       * The AxisMaps are expensive to render on large data sets\n       * so provide the ability to store them in state and only update them when necessary\n       * they are dependent upon the start and end index of\n       * the brush so it's important that this method is called _after_\n       * the state is updated with any new start/end indices\n       *\n       * @param {Object} props The props object to be used for updating the axismaps\n       * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n       * @param {Number} dataEndIndex The end index of the data series when a brush is applied\n       * @return {Object} state New state to set\n       */\n    }, {\n      key: 'updateStateOfAxisMapsOffsetAndStackGroups',\n      value: function updateStateOfAxisMapsOffsetAndStackGroups(_ref8) {\n        var props = _ref8.props,\n          dataStartIndex = _ref8.dataStartIndex,\n          dataEndIndex = _ref8.dataEndIndex;\n        var data = props.data;\n        if (!validateWidthHeight({\n          props: props\n        }) || !data || !data.length) {\n          return null;\n        }\n        var children = props.children,\n          layout = props.layout,\n          stackOffset = props.stackOffset;\n        var numericIdName = layout === 'horizontal' ? 'yAxis' : 'xAxis';\n        var cateIdName = layout === 'horizontal' ? 'xAxis' : 'yAxis';\n        var graphicalItems = findAllByType(children, GraphicalChild);\n        var stackGroups = getStackGroupsByAxisId(data, graphicalItems, numericIdName + 'Id', cateIdName + 'Id', stackOffset);\n        var xAxisMap = this.getAxisMap(props, {\n          axisType: 'xAxis',\n          graphicalItems: graphicalItems,\n          stackGroups: numericIdName === 'xAxis' && stackGroups,\n          dataStartIndex: dataStartIndex,\n          dataEndIndex: dataEndIndex\n        });\n        var yAxisMap = this.getAxisMap(props, {\n          axisType: 'yAxis',\n          graphicalItems: graphicalItems,\n          stackGroups: numericIdName === 'yAxis' && stackGroups,\n          dataStartIndex: dataStartIndex,\n          dataEndIndex: dataEndIndex\n        });\n        var offset = this.calculateOffset(props, graphicalItems, xAxisMap, yAxisMap);\n        xAxisMap = this.getFormatAxisMap(props, xAxisMap, offset, 'xAxis');\n        yAxisMap = this.getFormatAxisMap(props, yAxisMap, offset, 'yAxis');\n        var ticksObj = this.tooltipTicksGenerator({\n          layout: layout,\n          xAxisMap: xAxisMap,\n          yAxisMap: yAxisMap\n        });\n        return _extends({\n          graphicalItems: graphicalItems,\n          xAxisMap: xAxisMap,\n          yAxisMap: yAxisMap,\n          offset: offset,\n          stackGroups: stackGroups\n        }, ticksObj);\n      }\n\n      /* eslint-disable  no-underscore-dangle */\n    }, {\n      key: 'addListener',\n      value: function addListener() {\n        eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);\n        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {\n          eventCenter.setMaxListeners(eventCenter._maxListeners + 1);\n        }\n      }\n    }, {\n      key: 'removeListener',\n      value: function removeListener() {\n        eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);\n        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {\n          eventCenter.setMaxListeners(eventCenter._maxListeners - 1);\n        }\n      }\n      /**\n       * Returns default, reset state for the categorical chart.\n       * @param {Object} props Props object to use when creating the default state\n       * @return {Object} Whole new state\n       */\n    }, {\n      key: 'createDefaultState',\n      value: function createDefaultState(props) {\n        var children = props.children;\n        var brushItem = findChildByType(children, Brush);\n        var startIndex = brushItem && brushItem.props && brushItem.props.startIndex || 0;\n        var endIndex = brushItem && brushItem.props && brushItem.props.endIndex || props.data && props.data.length - 1 || 0;\n        return {\n          chartX: 0,\n          chartY: 0,\n          dataStartIndex: startIndex,\n          dataEndIndex: endIndex,\n          activeTooltipIndex: -1,\n          isTooltipActive: false\n        };\n      }\n      /**\n       * Calculate the offset of main part in the svg element\n       * @param  {Object} props          Latest props\n       * @param  {Array}  graphicalItems The instances of item\n       * @param  {Object} xAxisMap       The configuration of x-axis\n       * @param  {Object} yAxisMap       The configuration of y-axis\n       * @return {Object} The offset of main part in the svg element\n       */\n    }, {\n      key: 'calculateOffset',\n      value: function calculateOffset(props, graphicalItems, xAxisMap, yAxisMap) {\n        var width = props.width,\n          height = props.height,\n          children = props.children;\n        var margin = props.margin || {};\n        var brushItem = findChildByType(children, Brush);\n        var legendItem = findChildByType(children, Legend);\n        var offsetH = Object.keys(yAxisMap).reduce(function (result, id) {\n          var entry = yAxisMap[id];\n          var orientation = entry.orientation;\n          if (!entry.mirror && !entry.hide) {\n            return _extends({}, result, _defineProperty({}, orientation, result[orientation] + entry.width));\n          }\n          return result;\n        }, {\n          left: margin.left || 0,\n          right: margin.right || 0\n        });\n        var offsetV = Object.keys(xAxisMap).reduce(function (result, id) {\n          var entry = xAxisMap[id];\n          var orientation = entry.orientation;\n          if (!entry.mirror && !entry.hide) {\n            return _extends({}, result, _defineProperty({}, orientation, result[orientation] + entry.height));\n          }\n          return result;\n        }, {\n          top: margin.top || 0,\n          bottom: margin.bottom || 0\n        });\n        var offset = _extends({}, offsetV, offsetH);\n        var brushBottom = offset.bottom;\n        if (brushItem) {\n          offset.bottom += brushItem.props.height || Brush.defaultProps.height;\n        }\n        if (legendItem && this.legendInstance) {\n          var legendBox = this.legendInstance.getBBox();\n          offset = appendOffsetOfLegend(offset, graphicalItems, props, legendBox);\n        }\n        return _extends({\n          brushBottom: brushBottom\n        }, offset, {\n          width: width - offset.left - offset.right,\n          height: height - offset.top - offset.bottom\n        });\n      }\n      /**\n       * The handler of mouse entering chart\n       * @param  {Object} e              Event object\n       * @return {Null}                  null\n       */\n\n      /**\n       * The handler of mouse moving in chart\n       * @param  {Object} e        Event object\n       * @return {Null} no return\n       */\n\n      /**\n       * The handler if mouse leaving chart\n       * @param {Object} e Event object\n       * @return {Null} no return\n       */\n    }, {\n      key: 'validateAxes',\n      value: function validateAxes() {\n        var _props2 = this.props,\n          layout = _props2.layout,\n          children = _props2.children;\n        var xAxes = findAllByType(children, XAxis);\n        var yAxes = findAllByType(children, YAxis);\n        if (layout === 'horizontal' && xAxes && xAxes.length) {\n          xAxes.forEach(function (axis) {\n            warn(axis.props.type === 'category' || axis.props.type === 'number' && !_isNil(axis.props.dataKey), 'x-axis should be a category axis or a number axis which has specifed dataKey\\n             when the layout is horizontal');\n          });\n        } else if (layout === 'vertical') {\n          var displayName = this.constructor.displayName;\n          warn(yAxes && yAxes.length, 'You should add <YAxis type=\"number\" /> in ' + displayName + '.\\n           The layout is vertical now, y-axis should be category axis,\\n           but y-axis is number axis when no YAxis is added.');\n          warn(xAxes && xAxes.length, 'You should add <XAxis /> in ' + displayName + '.\\n          The layout is vertical now, x-axis is category when no XAxis is added.');\n          if (yAxes && yAxes.length) {\n            yAxes.forEach(function (axis) {\n              warn(axis.props.type === 'category' || axis.props.type === 'number' && !_isNil(axis.props.dataKey), 'y-axis should be a category axis or a number axis which has specifed dataKey\\n               when the layout is vertical');\n            });\n          }\n        }\n        return null;\n      }\n    }, {\n      key: 'triggerSyncEvent',\n      value: function triggerSyncEvent(data) {\n        var syncId = this.props.syncId;\n        if (!_isNil(syncId)) {\n          eventCenter.emit(SYNC_EVENT, syncId, this.uniqueChartId, data);\n        }\n      }\n    }, {\n      key: 'renderAxes',\n      /**\n       * Draw axes\n       * @param {Object} axisMap The configuration of all x-axes or y-axes\n       * @param {String} name    The name of axes\n       * @return {ReactElement}  The instance of x-axes\n       */\n      value: function renderAxes(axisMap, name) {\n        var _props3 = this.props,\n          width = _props3.width,\n          height = _props3.height;\n        var ids = axisMap && Object.keys(axisMap);\n        if (ids && ids.length) {\n          var axes = [];\n          for (var i = 0, len = ids.length; i < len; i++) {\n            var axis = axisMap[ids[i]];\n            if (!axis.hide) {\n              axes.push(React.createElement(CartesianAxis, _extends({}, axis, {\n                key: name + '-' + ids[i],\n                viewBox: {\n                  x: 0,\n                  y: 0,\n                  width: width,\n                  height: height\n                },\n                ticksGenerator: this.axesTicksGenerator\n              })));\n            }\n          }\n          return axes.length ? React.createElement(Layer, {\n            key: name + '-layer',\n            className: 'recharts-' + name\n          }, axes) : null;\n        }\n        return null;\n      }\n\n      /**\n       * Draw grid\n       * @return {ReactElement} The instance of grid\n       */\n    }, {\n      key: 'renderGrid',\n      value: function renderGrid() {\n        var _state4 = this.state,\n          xAxisMap = _state4.xAxisMap,\n          yAxisMap = _state4.yAxisMap,\n          offset = _state4.offset;\n        var _props4 = this.props,\n          children = _props4.children,\n          width = _props4.width,\n          height = _props4.height;\n        var gridItem = findChildByType(children, CartesianGrid);\n        if (!gridItem) {\n          return null;\n        }\n        var xAxis = getAnyElementOfObject(xAxisMap);\n        var yAxis = getAnyElementOfObject(yAxisMap);\n        return React.cloneElement(gridItem, {\n          key: 'grid',\n          x: offset.left,\n          y: offset.top,\n          width: offset.width,\n          height: offset.height,\n          xAxis: xAxis,\n          yAxis: yAxis,\n          offset: offset,\n          chartWidth: width,\n          chartHeight: height,\n          verticalCoordinatesGenerator: this.verticalCoordinatesGenerator,\n          horizontalCoordinatesGenerator: this.horizontalCoordinatesGenerator\n        });\n      }\n      /**\n       * Draw legend\n       * @return {ReactElement}            The instance of Legend\n       */\n    }, {\n      key: 'renderLegend',\n      value: function renderLegend() {\n        var _this2 = this;\n        var graphicalItems = this.state.graphicalItems;\n        var _props5 = this.props,\n          children = _props5.children,\n          width = _props5.width,\n          height = _props5.height;\n        var margin = this.props.margin || {};\n        var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n        var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n        var props = getLegendProps(children, graphicalItems, legendWidth, legendHeight);\n        if (!props) {\n          return null;\n        }\n        return React.createElement(Legend, _extends({}, props, {\n          chartWidth: width,\n          chartHeight: height,\n          margin: margin,\n          ref: function ref(legend) {\n            _this2.legendInstance = legend;\n          },\n          onBBoxUpdate: this.handleLegendBBoxUpdate\n        }));\n      }\n\n      /**\n       * Draw Tooltip\n       * @return {ReactElement}  The instance of Tooltip\n       */\n    }, {\n      key: 'renderTooltip',\n      value: function renderTooltip() {\n        var children = this.props.children;\n        var tooltipItem = findChildByType(children, Tooltip);\n        if (!tooltipItem) {\n          return null;\n        }\n        var _state5 = this.state,\n          isTooltipActive = _state5.isTooltipActive,\n          activeCoordinate = _state5.activeCoordinate,\n          activePayload = _state5.activePayload,\n          activeLabel = _state5.activeLabel,\n          offset = _state5.offset;\n        return React.cloneElement(tooltipItem, {\n          viewBox: _extends({}, offset, {\n            x: offset.left,\n            y: offset.top\n          }),\n          active: isTooltipActive,\n          label: activeLabel,\n          payload: isTooltipActive ? activePayload : [],\n          coordinate: activeCoordinate\n        });\n      }\n    }, {\n      key: 'renderBrush',\n      value: function renderBrush() {\n        var _props6 = this.props,\n          children = _props6.children,\n          margin = _props6.margin,\n          data = _props6.data;\n        var _state6 = this.state,\n          offset = _state6.offset,\n          dataStartIndex = _state6.dataStartIndex,\n          dataEndIndex = _state6.dataEndIndex,\n          updateId = _state6.updateId;\n        var brushItem = findChildByType(children, Brush);\n        if (!brushItem) {\n          return null;\n        }\n\n        // TODO: update brush when children update\n        return React.cloneElement(brushItem, {\n          onChange: combineEventHandlers(this.handleBrushChange, null, brushItem.props.onChange),\n          data: data,\n          x: offset.left,\n          y: offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),\n          width: offset.width,\n          startIndex: dataStartIndex,\n          endIndex: dataEndIndex,\n          updateId: 'brush-' + updateId\n        });\n      }\n    }, {\n      key: 'renderReferenceElements',\n      value: function renderReferenceElements(isFront, Compt) {\n        var children = this.props.children;\n        var elements = findAllByType(children, Compt);\n        if (!elements || !elements.length) {\n          return null;\n        }\n        var _state7 = this.state,\n          xAxisMap = _state7.xAxisMap,\n          yAxisMap = _state7.yAxisMap,\n          offset = _state7.offset;\n        var keyPrefix = getDisplayName(Compt) + '-' + (isFront ? 'front' : 'back');\n        return elements.filter(function (entry) {\n          return isFront === entry.props.isFront;\n        }).map(function (entry, i) {\n          var _entry$props = entry.props,\n            xAxisId = _entry$props.xAxisId,\n            yAxisId = _entry$props.yAxisId;\n          return React.cloneElement(entry, {\n            key: keyPrefix + '-' + i,\n            xAxis: xAxisMap[xAxisId],\n            yAxis: yAxisMap[yAxisId],\n            viewBox: {\n              x: offset.left,\n              y: offset.top,\n              width: offset.width,\n              height: offset.height\n            }\n          });\n        });\n      }\n    }, {\n      key: 'renderChart',\n      value: function renderChart() {\n        var _props7 = this.props,\n          children = _props7.children,\n          width = _props7.width,\n          height = _props7.height,\n          others = _objectWithoutProperties(_props7, ['children', 'width', 'height']);\n        var _state8 = this.state,\n          xAxisMap = _state8.xAxisMap,\n          yAxisMap = _state8.yAxisMap;\n        var attrs = getPresentationAttributes(others);\n        return React.createElement(Surface, _extends({}, attrs, {\n          width: width,\n          height: height\n        }), this.renderGrid(), this.renderReferenceElements(false, ReferenceArea), this.renderReferenceElements(false, ReferenceLine), this.renderReferenceElements(false, ReferenceDot), this.renderAxes(xAxisMap, 'x-axis'), this.renderAxes(yAxisMap, 'y-axis'), React.createElement(ChartComponent, _extends({}, this.props, this.state)), this.renderReferenceElements(true, ReferenceArea), this.renderReferenceElements(true, ReferenceLine), this.renderReferenceElements(true, ReferenceDot), this.renderBrush(), filterSvgElements(children));\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this3 = this;\n        var data = this.props.data;\n        if (!validateWidthHeight(this) || !data || !data.length) {\n          return null;\n        }\n        var _props8 = this.props,\n          className = _props8.className,\n          width = _props8.width,\n          height = _props8.height,\n          style = _props8.style,\n          compact = _props8.compact;\n        var events = {\n          onMouseEnter: this.handleMouseEnter,\n          onMouseMove: this.handleMouseMove,\n          onMouseLeave: this.handleMouseLeave,\n          onClick: this.handleClick,\n          onMouseDown: this.handleMouseDown,\n          onMouseUp: this.handleMouseUp,\n          onTouchMove: this.handleTouchMove\n        };\n\n        // The \"compact\" mode is mainly used as the panorama within Brush\n        if (compact) {\n          return this.renderChart();\n        }\n        return React.createElement('div', _extends({\n          className: classNames('recharts-wrapper', className),\n          style: _extends({}, style, {\n            position: 'relative',\n            cursor: 'default',\n            width: width,\n            height: height\n          })\n        }, events, {\n          ref: function ref(node) {\n            _this3.container = node;\n          }\n        }), this.renderChart(), this.renderLegend(), this.renderTooltip());\n      }\n    }]);\n    return CategoricalChartWrapper;\n  }(Component), _class.displayName = getDisplayName(ChartComponent), _class.propTypes = _extends({}, ChartComponent.propTypes, {\n    syncId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    compact: PropTypes.bool,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    data: PropTypes.arrayOf(PropTypes.object),\n    layout: PropTypes.oneOf(['horizontal', 'vertical']),\n    stackOffset: PropTypes.oneOf(['sign', 'expand', 'none', 'wiggle', 'silhouette']),\n    throttleDelay: PropTypes.number,\n    margin: PropTypes.shape({\n      top: PropTypes.number,\n      right: PropTypes.number,\n      bottom: PropTypes.number,\n      left: PropTypes.number\n    }),\n    style: PropTypes.object,\n    className: PropTypes.string,\n    children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n    onClick: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func\n  }), _class.defaultProps = {\n    layout: 'horizontal',\n    stackOffset: 'none',\n    margin: {\n      top: 5,\n      right: 5,\n      bottom: 5,\n      left: 5\n    }\n  }, _temp);\n  return CategoricalChartWrapper;\n};\nexport default generateCategoricalChart;","map":null,"metadata":{},"sourceType":"module"}