{"ast":null,"code":"'use strict';\n\nvar Mexp = require('./math_function.js');\nfunction inc(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    arr[i] += val;\n  }\n  return arr;\n}\nvar tokens = [{\n  token: 'sin',\n  show: 'sin',\n  type: 0,\n  value: Mexp.math.sin\n}, {\n  token: 'cos',\n  show: 'cos',\n  type: 0,\n  value: Mexp.math.cos\n}, {\n  token: 'tan',\n  show: 'tan',\n  type: 0,\n  value: Mexp.math.tan\n}, {\n  token: 'pi',\n  show: '&pi;',\n  type: 3,\n  value: 'PI'\n}, {\n  token: '(',\n  show: '(',\n  type: 4,\n  value: '('\n}, {\n  token: ')',\n  show: ')',\n  type: 5,\n  value: ')'\n}, {\n  token: 'P',\n  show: 'P',\n  type: 10,\n  value: Mexp.math.P\n}, {\n  token: 'C',\n  show: 'C',\n  type: 10,\n  value: Mexp.math.C\n}, {\n  token: ' ',\n  show: ' ',\n  type: 14,\n  value: ' '.anchor\n}, {\n  token: 'asin',\n  show: 'asin',\n  type: 0,\n  value: Mexp.math.asin\n}, {\n  token: 'acos',\n  show: 'acos',\n  type: 0,\n  value: Mexp.math.acos\n}, {\n  token: 'atan',\n  show: 'atan',\n  type: 0,\n  value: Mexp.math.atan\n}, {\n  token: '7',\n  show: '7',\n  type: 1,\n  value: '7'\n}, {\n  token: '8',\n  show: '8',\n  type: 1,\n  value: '8'\n}, {\n  token: '9',\n  show: '9',\n  type: 1,\n  value: '9'\n}, {\n  token: 'int',\n  show: 'Int',\n  type: 0,\n  value: Math.floor\n}, {\n  token: 'cosh',\n  show: 'cosh',\n  type: 0,\n  value: Mexp.math.cosh\n}, {\n  token: 'acosh',\n  show: 'acosh',\n  type: 0,\n  value: Mexp.math.acosh\n}, {\n  token: 'ln',\n  show: ' ln',\n  type: 0,\n  value: Math.log\n}, {\n  token: '^',\n  show: '^',\n  type: 10,\n  value: Math.pow\n}, {\n  token: 'root',\n  show: 'root',\n  type: 0,\n  value: Math.sqrt\n}, {\n  token: '4',\n  show: '4',\n  type: 1,\n  value: '4'\n}, {\n  token: '5',\n  show: '5',\n  type: 1,\n  value: '5'\n}, {\n  token: '6',\n  show: '6',\n  type: 1,\n  value: '6'\n}, {\n  token: '/',\n  show: '&divide;',\n  type: 2,\n  value: Mexp.math.div\n}, {\n  token: '!',\n  show: '!',\n  type: 7,\n  value: Mexp.math.fact\n}, {\n  token: 'tanh',\n  show: 'tanh',\n  type: 0,\n  value: Mexp.math.tanh\n}, {\n  token: 'atanh',\n  show: 'atanh',\n  type: 0,\n  value: Mexp.math.atanh\n}, {\n  token: 'Mod',\n  show: ' Mod ',\n  type: 2,\n  value: Mexp.math.mod\n}, {\n  token: '1',\n  show: '1',\n  type: 1,\n  value: '1'\n}, {\n  token: '2',\n  show: '2',\n  type: 1,\n  value: '2'\n}, {\n  token: '3',\n  show: '3',\n  type: 1,\n  value: '3'\n}, {\n  token: '*',\n  show: '&times;',\n  type: 2,\n  value: Mexp.math.mul\n}, {\n  token: 'sinh',\n  show: 'sinh',\n  type: 0,\n  value: Mexp.math.sinh\n}, {\n  token: 'asinh',\n  show: 'asinh',\n  type: 0,\n  value: Mexp.math.asinh\n}, {\n  token: 'e',\n  show: 'e',\n  type: 3,\n  value: 'E'\n}, {\n  token: 'log',\n  show: ' log',\n  type: 0,\n  value: Mexp.math.log\n}, {\n  token: '0',\n  show: '0',\n  type: 1,\n  value: '0'\n}, {\n  token: '.',\n  show: '.',\n  type: 6,\n  value: '.'\n}, {\n  token: '+',\n  show: '+',\n  type: 9,\n  value: Mexp.math.add\n}, {\n  token: '-',\n  show: '-',\n  type: 9,\n  value: Mexp.math.sub\n}, {\n  token: ',',\n  show: ',',\n  type: 11,\n  value: ','\n}, {\n  token: 'Sigma',\n  show: '&Sigma;',\n  type: 12,\n  value: Mexp.math.sigma\n}, {\n  token: 'n',\n  show: 'n',\n  type: 13,\n  value: 'n'\n}, {\n  token: 'Pi',\n  show: '&Pi;',\n  type: 12,\n  value: Mexp.math.Pi\n}, {\n  token: 'pow',\n  show: 'pow',\n  type: 8,\n  value: Math.pow,\n  numberOfArguments: 2\n}, {\n  token: '&',\n  show: '&',\n  type: 9,\n  value: Mexp.math.and\n}];\nvar preced = {\n  0: 11,\n  1: 0,\n  2: 3,\n  3: 0,\n  4: 0,\n  5: 0,\n  6: 0,\n  7: 11,\n  8: 11,\n  9: 1,\n  10: 10,\n  11: 0,\n  12: 11,\n  13: 0,\n  14: -1,\n  15: 11 // will be filtered after lexer\n}; // stores precedence by types\nfor (var i = 0; i < tokens.length; i++) {\n  tokens[i].precedence = preced[tokens[i].type];\n}\nvar type0 = {\n  0: true,\n  1: true,\n  3: true,\n  4: true,\n  6: true,\n  8: true,\n  9: true,\n  12: true,\n  13: true,\n  14: true,\n  15: true\n}; // type2:true,type4:true,type9:true,type11:true,type21:true,type22\nvar type1 = {\n  0: true,\n  1: true,\n  2: true,\n  3: true,\n  4: true,\n  5: true,\n  6: true,\n  7: true,\n  8: true,\n  9: true,\n  10: true,\n  11: true,\n  12: true,\n  13: true,\n  15: true\n}; // type3:true,type5:true,type7:true,type23\nvar type1Asterick = {\n  0: true,\n  3: true,\n  4: true,\n  8: true,\n  12: true,\n  13: true,\n  15: true\n};\nvar empty = {};\nvar type3Asterick = {\n  0: true,\n  1: true,\n  3: true,\n  4: true,\n  6: true,\n  8: true,\n  12: true,\n  13: true,\n  15: true\n}; // type_5:true,type_7:true,type_23\nvar type6 = {\n  1: true\n};\nvar newAr = [[], ['1', '2', '3', '7', '8', '9', '4', '5', '6', '+', '-', '*', '/', '(', ')', '^', '!', 'P', 'C', 'e', '0', '.', ',', 'n', ' ', '&'], ['pi', 'ln', 'Pi'], ['sin', 'cos', 'tan', 'Del', 'int', 'Mod', 'log', 'pow'], ['asin', 'acos', 'atan', 'cosh', 'root', 'tanh', 'sinh'], ['acosh', 'atanh', 'asinh', 'Sigma']];\nfunction match(str1, str2, i, x) {\n  for (var f = 0; f < x; f++) {\n    if (str1[i + f] !== str2[f]) {\n      return false;\n    }\n  }\n  return true;\n}\nMexp.tokenTypes = {\n  FUNCTION_WITH_ONE_ARG: 0,\n  NUMBER: 1,\n  BINARY_OPERATOR_HIGH_PRECENDENCE: 2,\n  CONSTANT: 3,\n  OPENING_PARENTHESIS: 4,\n  CLOSING_PARENTHESIS: 5,\n  DECIMAL: 6,\n  POSTFIX_FUNCTION_WITH_ONE_ARG: 7,\n  FUNCTION_WITH_N_ARGS: 8,\n  BINARY_OPERATOR_LOW_PRECENDENCE: 9,\n  BINARY_OPERATOR_PERMUTATION: 10,\n  COMMA: 11,\n  EVALUATED_FUNCTION: 12,\n  EVALUATED_FUNCTION_PARAMETER: 13,\n  SPACE: 14\n};\n/**\r\n  \r\n  0 : function with syntax function_name(Maths_exp)\r\n  1 : numbers\r\n  2 : binary operators like * / Mod left associate and same precedence\r\n  3 : Math constant values like e,pi,Cruncher ans\r\n  4 : opening bracket\r\n  5 : closing bracket\r\n  6 : decimal\r\n  7 : function with syntax (Math_exp)function_name\r\n  8: function with syntax function_name(Math_exp1,Math_exp2)\r\n  9 : binary operator like +,-\r\n  10: binary operator like P C or ^\r\n  11: ,\r\n  12: function with , seperated three parameters and third parameter is a string that will be mexp string\r\n  13: variable of Sigma function\r\n */\nMexp.addToken = function (newTokens) {\n  for (var i = 0; i < newTokens.length; i++) {\n    var x = newTokens[i].token.length;\n    var temp = -1;\n    if (newTokens[i].type === Mexp.tokenTypes.FUNCTION_WITH_N_ARGS && newTokens[i].numberOfArguments === undefined) {\n      newTokens[i].numberOfArguments = 2;\n    }\n\n    // newAr is a specially designed data structure index of 1d array = length of tokens\n    newAr[x] = newAr[x] || [];\n    for (var y = 0; y < newAr[x].length; y++) {\n      if (newTokens[i].token === newAr[x][y]) {\n        temp = indexOfToken(newAr[x][y], tokens);\n        break;\n      }\n    }\n    if (temp === -1) {\n      tokens.push(newTokens[i]);\n      newTokens[i].precedence = preced[newTokens[i].type];\n      if (newAr.length <= newTokens[i].token.length) {\n        newAr[newTokens[i].token.length] = [];\n      }\n      newAr[newTokens[i].token.length].push(newTokens[i].token);\n    } else {\n      // overwrite\n      tokens[temp] = newTokens[i];\n      newTokens[i].precedence = preced[newTokens[i].type];\n    }\n  }\n};\nfunction indexOfToken(key, tokens) {\n  for (var search = 0; search < tokens.length; search++) {\n    if (tokens[search].token === key) return search;\n  }\n  return -1;\n}\nfunction tokenize(string) {\n  var nodes = [];\n  var length = string.length;\n  var key, x, y;\n  for (var i = 0; i < length; i++) {\n    if (i < length - 1 && string[i] === ' ' && string[i + 1] === ' ') {\n      continue;\n    }\n    key = '';\n    for (x = string.length - i > newAr.length - 2 ? newAr.length - 1 : string.length - i; x > 0; x--) {\n      if (newAr[x] === undefined) continue;\n      for (y = 0; y < newAr[x].length; y++) {\n        if (match(string, newAr[x][y], i, x)) {\n          key = newAr[x][y];\n          y = newAr[x].length;\n          x = 0;\n        }\n      }\n    }\n    i += key.length - 1;\n    if (key === '') {\n      throw new Mexp.Exception(\"Can't understand after \" + string.slice(i));\n    }\n    nodes.push(tokens[indexOfToken(key, tokens)]);\n  }\n  return nodes;\n}\nvar changeSignObj = {\n  value: Mexp.math.changeSign,\n  type: 0,\n  pre: 21,\n  show: '-'\n};\nvar closingParObj = {\n  value: ')',\n  show: ')',\n  type: 5,\n  pre: 0\n};\nvar openingParObj = {\n  value: '(',\n  type: 4,\n  pre: 0,\n  show: '('\n};\nMexp.lex = function (inp, tokens) {\n  'use strict';\n\n  var str = [openingParObj];\n  var ptc = []; // Parenthesis to close at the beginning is after one token\n  var inpStr = inp;\n  var allowed = type0;\n  var bracToClose = 0;\n  var asterick = empty;\n  var prevKey = '';\n  var i;\n  if (typeof tokens !== 'undefined') {\n    Mexp.addToken(tokens);\n  }\n  var obj = {};\n  var nodes = tokenize(inpStr);\n  for (i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (node.type === 14) {\n      if (i > 0 && i < nodes.length - 1 && nodes[i + 1].type === 1 && (nodes[i - 1].type === 1 || nodes[i - 1].type === 6)) {\n        throw new Mexp.Exception('Unexpected Space');\n      }\n      continue;\n    }\n    var cToken = node.token;\n    var cType = node.type;\n    var cEv = node.value;\n    var cPre = node.precedence;\n    var cShow = node.show;\n    var pre = str[str.length - 1];\n    var j;\n    for (j = ptc.length; j--;) {\n      // loop over ptc\n      if (ptc[j] === 0) {\n        if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {\n          if (allowed[cType] !== true) {\n            throw new Mexp.Exception(cToken + ' is not allowed after ' + prevKey);\n          }\n          str.push(closingParObj);\n          allowed = type1;\n          asterick = type3Asterick;\n          ptc.pop();\n        }\n      } else break;\n    }\n    if (allowed[cType] !== true) {\n      throw new Mexp.Exception(cToken + ' is not allowed after ' + prevKey);\n    }\n    if (asterick[cType] === true) {\n      cType = 2;\n      cEv = Mexp.math.mul;\n      cShow = '&times;';\n      cPre = 3;\n      i = i - 1;\n    }\n    obj = {\n      value: cEv,\n      type: cType,\n      pre: cPre,\n      show: cShow,\n      numberOfArguments: node.numberOfArguments\n    };\n    if (cType === 0) {\n      allowed = type0;\n      asterick = empty;\n      inc(ptc, 2);\n      str.push(obj);\n      if (nodes[i + 1].type !== 4) {\n        str.push(openingParObj);\n        ptc.push(2);\n      }\n      // bracToClose++\n    } else if (cType === 1) {\n      if (pre.type === 1) {\n        pre.value += cEv;\n        inc(ptc, 1);\n      } else {\n        str.push(obj);\n      }\n      allowed = type1;\n      asterick = type1Asterick;\n    } else if (cType === 2) {\n      allowed = type0;\n      asterick = empty;\n      inc(ptc, 2);\n      str.push(obj);\n    } else if (cType === 3) {\n      // constant\n      str.push(obj);\n      allowed = type1;\n      asterick = type3Asterick;\n    } else if (cType === 4) {\n      inc(ptc, 1);\n      bracToClose++;\n      allowed = type0;\n      asterick = empty;\n      str.push(obj);\n    } else if (cType === 5) {\n      if (!bracToClose) {\n        throw new Mexp.Exception('Closing parenthesis are more than opening one, wait What!!!');\n      }\n      bracToClose--;\n      allowed = type1;\n      asterick = type3Asterick;\n      str.push(obj);\n      inc(ptc, 1);\n    } else if (cType === 6) {\n      if (pre.hasDec) {\n        throw new Mexp.Exception('Two decimals are not allowed in one number');\n      }\n      if (pre.type !== 1) {\n        pre = {\n          value: 0,\n          type: 1,\n          pre: 0\n        }; // pre needs to be changed as it will the last value now to be safe in later code\n        str.push(pre);\n        // inc(ptc, 1)\n      }\n\n      allowed = type6;\n      inc(ptc, 1);\n      asterick = empty;\n      pre.value += cEv;\n      pre.hasDec = true;\n    } else if (cType === 7) {\n      allowed = type1;\n      asterick = type3Asterick;\n      inc(ptc, 1);\n      str.push(obj);\n    }\n    if (cType === 8) {\n      allowed = type0;\n      asterick = empty;\n      inc(ptc, node.numberOfArguments + 2);\n      str.push(obj);\n      // str.push(openingParObj)\n      if (nodes[i + 1].type !== 4) {\n        str.push(openingParObj);\n        ptc.push(node.numberOfArguments + 2);\n      }\n    } else if (cType === 9) {\n      if (pre.type === 9) {\n        if (pre.value === Mexp.math.add) {\n          pre.value = cEv;\n          pre.show = cShow;\n          inc(ptc, 1);\n        } else if (pre.value === Mexp.math.sub && cShow === '-') {\n          pre.value = Mexp.math.add;\n          pre.show = '+';\n          inc(ptc, 1);\n        }\n      } else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) {\n        // changesign only when negative is found\n        if (cToken === '-') {\n          // do nothing for + token\n          // don't add with the above if statement as that will run the else statement of parent if on Ctoken +\n          allowed = type0;\n          asterick = empty;\n          inc(ptc, 2).push(2);\n          str.push(changeSignObj);\n          str.push(openingParObj);\n        }\n      } else {\n        str.push(obj);\n        inc(ptc, 2);\n      }\n      allowed = type0;\n      asterick = empty;\n    } else if (cType === 10) {\n      allowed = type0;\n      asterick = empty;\n      inc(ptc, 2);\n      str.push(obj);\n    } else if (cType === 11) {\n      allowed = type0;\n      asterick = empty;\n      str.push(obj);\n    } else if (cType === 12) {\n      allowed = type0;\n      asterick = empty;\n      inc(ptc, 6);\n      str.push(obj);\n      if (nodes[i + 1].type !== 4) {\n        str.push(openingParObj);\n        ptc.push(6);\n      }\n    } else if (cType === 13) {\n      allowed = type1;\n      asterick = type3Asterick;\n      str.push(obj);\n    }\n    inc(ptc, -1);\n    prevKey = cToken;\n  }\n  for (j = ptc.length; j--;) {\n    // loop over ptc\n    str.push(closingParObj);\n  }\n  if (allowed[5] !== true) {\n    throw new Mexp.Exception('complete the expression');\n  }\n  while (bracToClose--) {\n    str.push(closingParObj);\n  }\n  str.push(closingParObj);\n  //        console.log(str);\n  return new Mexp(str);\n};\nmodule.exports = Mexp;","map":null,"metadata":{},"sourceType":"script"}