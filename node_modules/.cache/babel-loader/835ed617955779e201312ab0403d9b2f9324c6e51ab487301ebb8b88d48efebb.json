{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _utils = require('./utils');\n\n/**\n * 判断数据是否为浮点类型\n *\n * @param {Number} num 输入值\n * @return {Boolean} 是否是浮点类型\n */\nfunction isFloat(num) {\n  return /^([+-]?)\\d*\\.\\d+$/.test(num);\n}\n\n/**\n * 获取数值的位数\n * 其中绝对值属于区间[0.1, 1)， 得到的值为0\n * 绝对值属于区间[0.01, 0.1)，得到的位数为 -1\n * 绝对值属于区间[0.001, 0.01)，得到的位数为 -2\n *\n * @param  {Number} value 数值\n * @return {Integer} 位数\n */\n/**\n * @fileOverview 一些公用的运算方法\n * @author xile611\n * @date 2015-09-17\n */\nfunction getDigitCount(value) {\n  var abs = Math.abs(value);\n  var result = void 0;\n  if (value === 0) {\n    result = 1;\n  } else if (abs < 1) {\n    result = Math.floor(Math.log(abs) / Math.log(10)) + 1;\n  } else {\n    var str = '' + value;\n    var ary = str.split('.');\n    result = ary[0].length;\n  }\n  return result;\n}\n/**\n * 计算数值的小数点后的位数\n * @param  {Number} a 数值，可能为整数，也可能为浮点数\n * @return {Integer}   位数\n */\nfunction getDecimalDigitCount(a) {\n  var str = a ? '' + a : '';\n  var ary = str.split('.');\n  return ary.length > 1 ? ary[1].length : 0;\n}\n/**\n * 乘法运算，解决了js运算的精度问题\n * @param  {Number} a 被乘数\n * @param  {Number} b 乘数\n * @return {Number}   积\n */\nfunction multiply(a, b) {\n  var intA = parseInt(('' + a).replace('.', ''), 10);\n  var intB = parseInt(('' + b).replace('.', ''), 10);\n  var count = getDecimalDigitCount(a) + getDecimalDigitCount(b);\n  return intA * intB / Math.pow(10, count);\n}\n/**\n * 加法运算，解决了js运算的精度问题\n * @param  {Number} a 被加数\n * @param  {Number} b 加数\n * @return {Number}   和\n */\nfunction sum(a, b) {\n  var count = Math.max(getDecimalDigitCount(a), getDecimalDigitCount(b));\n  count = Math.pow(10, count);\n  return (multiply(a, count) + multiply(b, count)) / count;\n}\n/**\n * 减法运算，解决了js运算的精度问题\n * @param  {Number} a 被减数\n * @param  {Number} b 减数\n * @return {Number}   差\n */\nfunction minus(a, b) {\n  return sum(a, -b);\n}\n/**\n * 除法运算，解决了js运算的精度问题\n * @param  {Number} a 被除数\n * @param  {Number} b 除数\n * @return {Number}   结果\n */\nfunction divide(a, b) {\n  var ca = getDecimalDigitCount(a);\n  var cb = getDecimalDigitCount(b);\n  var intA = parseInt(('' + a).replace('.', ''), 10);\n  var intB = parseInt(('' + b).replace('.', ''), 10);\n  return intA / intB * Math.pow(10, cb - ca);\n}\nfunction modulo(a, b) {\n  var mod = Math.abs(b);\n  if (b <= 0) {\n    return a;\n  }\n  var cnt = Math.floor(a / mod);\n  return minus(a, multiply(mod, cnt));\n}\n\n/**\n * 按照固定的步长获取[start, end)这个区间的数据\n * 并且需要处理js计算精度的问题\n *\n * @param  {Number} start 起点\n * @param  {Number} end   终点，不包含该值\n * @param  {Number} step  步长\n * @return {Array}        若干数值\n */\nfunction rangeStep(start, end, step) {\n  var num = start;\n  var result = [];\n  while (num < end) {\n    result.push(num);\n    num = sum(num, step);\n  }\n  return result;\n}\n/**\n * 对数值进行线性插值\n *\n * @param  {Number} a  定义域的极点\n * @param  {Number} b  定义域的极点\n * @param  {Number} t  [0, 1]内的某个值\n * @return {Number}    定义域内的某个值\n */\nvar interpolateNumber = (0, _utils.curry)(function (a, b, t) {\n  var newA = +a;\n  var newB = +b;\n  return newA + t * (newB - newA);\n});\n/**\n * 线性插值的逆运算\n *\n * @param  {Number} a 定义域的极点\n * @param  {Number} b 定义域的极点\n * @param  {Number} x 可以认为是插值后的一个输出值\n * @return {Number}   当x在 a ~ b这个范围内时，返回值属于[0, 1]\n */\nvar uninterpolateNumber = (0, _utils.curry)(function (a, b, x) {\n  var diff = b - +a;\n  diff = diff || Infinity;\n  return (x - a) / diff;\n});\n/**\n * 线性插值的逆运算，并且有截断的操作\n *\n * @param  {Number} a 定义域的极点\n * @param  {Number} b 定义域的极点\n * @param  {Number} x 可以认为是插值后的一个输出值\n * @return {Number}   当x在 a ~ b这个区间内时，返回值属于[0, 1]，\n * 当x不在 a ~ b这个区间时，会截断到 a ~ b 这个区间\n */\nvar uninterpolateTruncation = (0, _utils.curry)(function (a, b, x) {\n  var diff = b - +a;\n  diff = diff || Infinity;\n  return Math.max(0, Math.min(1, (x - a) / diff));\n});\nexports.default = {\n  rangeStep: rangeStep,\n  isFloat: isFloat,\n  getDigitCount: getDigitCount,\n  getDecimalDigitCount: getDecimalDigitCount,\n  sum: sum,\n  minus: minus,\n  multiply: multiply,\n  divide: divide,\n  modulo: modulo,\n  interpolateNumber: interpolateNumber,\n  uninterpolateNumber: uninterpolateNumber,\n  uninterpolateTruncation: uninterpolateTruncation\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","_utils","require","isFloat","num","test","getDigitCount","abs","Math","result","floor","log","str","ary","split","length","getDecimalDigitCount","a","multiply","b","intA","parseInt","replace","intB","count","pow","sum","max","minus","divide","ca","cb","modulo","mod","cnt","rangeStep","start","end","step","push","interpolateNumber","curry","t","newA","newB","uninterpolateNumber","x","diff","Infinity","uninterpolateTruncation","min","default"],"sources":["/home/alam/Desktop/ReactProject/leaderboard/node_modules/recharts-scale/lib/util/arithmetic.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = require('./utils');\n\n/**\n * 判断数据是否为浮点类型\n *\n * @param {Number} num 输入值\n * @return {Boolean} 是否是浮点类型\n */\nfunction isFloat(num) {\n  return (/^([+-]?)\\d*\\.\\d+$/.test(num)\n  );\n}\n\n/**\n * 获取数值的位数\n * 其中绝对值属于区间[0.1, 1)， 得到的值为0\n * 绝对值属于区间[0.01, 0.1)，得到的位数为 -1\n * 绝对值属于区间[0.001, 0.01)，得到的位数为 -2\n *\n * @param  {Number} value 数值\n * @return {Integer} 位数\n */\n/**\n * @fileOverview 一些公用的运算方法\n * @author xile611\n * @date 2015-09-17\n */\nfunction getDigitCount(value) {\n  var abs = Math.abs(value);\n  var result = void 0;\n\n  if (value === 0) {\n    result = 1;\n  } else if (abs < 1) {\n    result = Math.floor(Math.log(abs) / Math.log(10)) + 1;\n  } else {\n    var str = '' + value;\n    var ary = str.split('.');\n\n    result = ary[0].length;\n  }\n\n  return result;\n}\n/**\n * 计算数值的小数点后的位数\n * @param  {Number} a 数值，可能为整数，也可能为浮点数\n * @return {Integer}   位数\n */\nfunction getDecimalDigitCount(a) {\n  var str = a ? '' + a : '';\n  var ary = str.split('.');\n\n  return ary.length > 1 ? ary[1].length : 0;\n}\n/**\n * 乘法运算，解决了js运算的精度问题\n * @param  {Number} a 被乘数\n * @param  {Number} b 乘数\n * @return {Number}   积\n */\nfunction multiply(a, b) {\n  var intA = parseInt(('' + a).replace('.', ''), 10);\n  var intB = parseInt(('' + b).replace('.', ''), 10);\n  var count = getDecimalDigitCount(a) + getDecimalDigitCount(b);\n\n  return intA * intB / Math.pow(10, count);\n}\n/**\n * 加法运算，解决了js运算的精度问题\n * @param  {Number} a 被加数\n * @param  {Number} b 加数\n * @return {Number}   和\n */\nfunction sum(a, b) {\n  var count = Math.max(getDecimalDigitCount(a), getDecimalDigitCount(b));\n\n  count = Math.pow(10, count);\n\n  return (multiply(a, count) + multiply(b, count)) / count;\n}\n/**\n * 减法运算，解决了js运算的精度问题\n * @param  {Number} a 被减数\n * @param  {Number} b 减数\n * @return {Number}   差\n */\nfunction minus(a, b) {\n  return sum(a, -b);\n}\n/**\n * 除法运算，解决了js运算的精度问题\n * @param  {Number} a 被除数\n * @param  {Number} b 除数\n * @return {Number}   结果\n */\nfunction divide(a, b) {\n  var ca = getDecimalDigitCount(a);\n  var cb = getDecimalDigitCount(b);\n  var intA = parseInt(('' + a).replace('.', ''), 10);\n  var intB = parseInt(('' + b).replace('.', ''), 10);\n\n  return intA / intB * Math.pow(10, cb - ca);\n}\n\nfunction modulo(a, b) {\n  var mod = Math.abs(b);\n\n  if (b <= 0) {\n    return a;\n  }\n\n  var cnt = Math.floor(a / mod);\n\n  return minus(a, multiply(mod, cnt));\n}\n\n/**\n * 按照固定的步长获取[start, end)这个区间的数据\n * 并且需要处理js计算精度的问题\n *\n * @param  {Number} start 起点\n * @param  {Number} end   终点，不包含该值\n * @param  {Number} step  步长\n * @return {Array}        若干数值\n */\nfunction rangeStep(start, end, step) {\n  var num = start;\n  var result = [];\n\n  while (num < end) {\n    result.push(num);\n\n    num = sum(num, step);\n  }\n\n  return result;\n}\n/**\n * 对数值进行线性插值\n *\n * @param  {Number} a  定义域的极点\n * @param  {Number} b  定义域的极点\n * @param  {Number} t  [0, 1]内的某个值\n * @return {Number}    定义域内的某个值\n */\nvar interpolateNumber = (0, _utils.curry)(function (a, b, t) {\n  var newA = +a;\n  var newB = +b;\n\n  return newA + t * (newB - newA);\n});\n/**\n * 线性插值的逆运算\n *\n * @param  {Number} a 定义域的极点\n * @param  {Number} b 定义域的极点\n * @param  {Number} x 可以认为是插值后的一个输出值\n * @return {Number}   当x在 a ~ b这个范围内时，返回值属于[0, 1]\n */\nvar uninterpolateNumber = (0, _utils.curry)(function (a, b, x) {\n  var diff = b - +a;\n\n  diff = diff || Infinity;\n\n  return (x - a) / diff;\n});\n/**\n * 线性插值的逆运算，并且有截断的操作\n *\n * @param  {Number} a 定义域的极点\n * @param  {Number} b 定义域的极点\n * @param  {Number} x 可以认为是插值后的一个输出值\n * @return {Number}   当x在 a ~ b这个区间内时，返回值属于[0, 1]，\n * 当x不在 a ~ b这个区间时，会截断到 a ~ b 这个区间\n */\nvar uninterpolateTruncation = (0, _utils.curry)(function (a, b, x) {\n  var diff = b - +a;\n\n  diff = diff || Infinity;\n\n  return Math.max(0, Math.min(1, (x - a) / diff));\n});\n\nexports.default = {\n  rangeStep: rangeStep,\n  isFloat: isFloat,\n  getDigitCount: getDigitCount,\n  getDecimalDigitCount: getDecimalDigitCount,\n\n  sum: sum,\n  minus: minus,\n  multiply: multiply,\n  divide: divide,\n  modulo: modulo,\n\n  interpolateNumber: interpolateNumber,\n  uninterpolateNumber: uninterpolateNumber,\n  uninterpolateTruncation: uninterpolateTruncation\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}