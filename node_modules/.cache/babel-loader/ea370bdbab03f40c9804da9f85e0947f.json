{"ast":null,"code":"import _isFunction from 'lodash/isFunction';\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _class, _class2, _temp2;\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * @fileOverview Line\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Animate from 'react-smooth';\nimport classNames from 'classnames';\nimport pureRender from '../util/PureRender';\nimport Curve from '../shape/Curve';\nimport Dot from '../shape/Dot';\nimport Layer from '../container/Layer';\nimport Text from '../component/Text';\nimport ErrorBar from './ErrorBar';\nimport { getValueByDataKey, uniqueId } from '../util/DataUtils';\nimport { PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, LEGEND_TYPES, getPresentationAttributes, isSsr, findChildByType } from '../util/ReactUtils';\nvar FACTOR = 1.0000001;\nvar Line = pureRender(_class = (_temp2 = _class2 = function (_Component) {\n  _inherits(Line, _Component);\n  function Line() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, Line);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Line.__proto__ || Object.getPrototypeOf(Line)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      isAnimationFinished: true,\n      totalLength: 0\n    }, _this.id = uniqueId('recharts-line-'), _this.pathRef = function (node) {\n      _this.animate = node;\n    }, _this.handleAnimationEnd = function () {\n      _this.setState({\n        isAnimationFinished: true\n      });\n      _this.props.onAnimationEnd();\n    }, _this.handleAnimationStart = function () {\n      _this.setState({\n        isAnimationFinished: false\n      });\n      _this.props.onAnimationStart();\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(Line, [{\n    key: 'componentDidMount',\n    /* eslint-disable  react/no-did-mount-set-state */\n    value: function componentDidMount() {\n      var isAnimationActive = this.props.isAnimationActive;\n      if (!isAnimationActive) {\n        return;\n      }\n      var totalLength = this.getTotalLength();\n      this.setState({\n        totalLength: totalLength\n      });\n    }\n\n    /* eslint-disable  react/no-did-update-set-state */\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var animationId = this.props.animationId;\n      if (animationId !== prevProps.animationId) {\n        var cur = this.getTotalLength();\n        var totalLength = prevState.totalLength;\n        // A hack method to trigger animation\n\n        this.setState({\n          totalLength: cur === totalLength ? cur * FACTOR : cur\n        });\n      }\n    }\n  }, {\n    key: 'getTotalLength',\n    value: function getTotalLength() {\n      var curveDom = this.animate;\n      var totalLength = curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;\n      return totalLength;\n    }\n  }, {\n    key: 'getStrokeDasharray',\n    value: function getStrokeDasharray(length, totalLength, lines) {\n      var lineLength = lines.reduce(function (pre, next) {\n        return pre + next;\n      });\n      var count = parseInt(length / lineLength, 10);\n      var remainLength = length % lineLength;\n      var restLength = totalLength - length;\n      var remainLines = [];\n      for (var i = 0, sum = 0;; sum += lines[i], ++i) {\n        if (sum + lines[i] > remainLength) {\n          remainLines = [].concat(_toConsumableArray(lines.slice(0, i)), [remainLength - sum]);\n          break;\n        }\n      }\n      var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n      return [].concat(_toConsumableArray(this.repeat(lines, count)), _toConsumableArray(remainLines), emptyLines).map(function (line) {\n        return line + 'px';\n      }).join(', ');\n    }\n  }, {\n    key: 'repeat',\n    value: function repeat(lines, count) {\n      var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray(lines), [0]) : lines;\n      var result = [];\n      for (var i = 0; i < count; ++i) {\n        result = [].concat(_toConsumableArray(result), _toConsumableArray(linesUnit));\n      }\n      return result;\n    }\n  }, {\n    key: 'renderLabelItem',\n    value: function renderLabelItem(option, props, value) {\n      var labelItem = void 0;\n      if (React.isValidElement(option)) {\n        labelItem = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        labelItem = option(props);\n      } else {\n        labelItem = React.createElement(Text, _extends({\n          key: props.key\n        }, props, {\n          className: 'recharts-line-label'\n        }), value);\n      }\n      return labelItem;\n    }\n  }, {\n    key: 'renderLabels',\n    value: function renderLabels() {\n      var _this2 = this;\n      var isAnimationActive = this.props.isAnimationActive;\n      if (isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props = this.props,\n        points = _props.points,\n        label = _props.label;\n      var lineProps = getPresentationAttributes(this.props);\n      var customLabelProps = getPresentationAttributes(label);\n      var labels = points.map(function (entry, i) {\n        var labelProps = _extends({\n          textAnchor: 'middle'\n        }, entry, lineProps, customLabelProps, {\n          index: i,\n          key: 'label-' + i\n        });\n        return _this2.renderLabelItem(label, labelProps, entry.value);\n      });\n      return React.createElement(Layer, {\n        className: 'recharts-line-labels'\n      }, labels);\n    }\n  }, {\n    key: 'renderErrorBar',\n    value: function renderErrorBar() {\n      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props2 = this.props,\n        points = _props2.points,\n        xAxis = _props2.xAxis,\n        yAxis = _props2.yAxis,\n        layout = _props2.layout,\n        children = _props2.children;\n      var errorBarItem = findChildByType(children, ErrorBar);\n      if (!errorBarItem) {\n        return null;\n      }\n      function dataPointFormatter(dataPoint, dataKey) {\n        return {\n          x: dataPoint.x,\n          y: dataPoint.y,\n          value: dataPoint.value,\n          errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n        };\n      }\n      return React.cloneElement(errorBarItem, {\n        data: points,\n        xAxis: xAxis,\n        yAxis: yAxis,\n        layout: layout,\n        dataPointFormatter: dataPointFormatter\n      });\n    }\n  }, {\n    key: 'renderDotItem',\n    value: function renderDotItem(option, props) {\n      var dotItem = void 0;\n      if (React.isValidElement(option)) {\n        dotItem = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        dotItem = option(props);\n      } else {\n        var className = classNames('recharts-line-dot', option.className);\n        dotItem = React.createElement(Dot, _extends({}, props, {\n          className: className\n        }));\n      }\n      return dotItem;\n    }\n  }, {\n    key: 'renderDots',\n    value: function renderDots() {\n      var _this3 = this;\n      var isAnimationActive = this.props.isAnimationActive;\n      if (isAnimationActive && !this.state.isAnimationFinished) {\n        return null;\n      }\n      var _props3 = this.props,\n        dot = _props3.dot,\n        points = _props3.points;\n      var lineProps = getPresentationAttributes(this.props);\n      var customDotProps = getPresentationAttributes(dot);\n      var dots = points.map(function (entry, i) {\n        var dotProps = _extends({\n          key: 'dot-' + i,\n          r: 3\n        }, lineProps, customDotProps, {\n          value: entry.value,\n          cx: entry.x,\n          cy: entry.y,\n          index: i,\n          payload: entry.payload\n        });\n        return _this3.renderDotItem(dot, dotProps);\n      });\n      return React.createElement(Layer, {\n        className: 'recharts-line-dots',\n        key: 'dots'\n      }, dots);\n    }\n  }, {\n    key: 'renderCurve',\n    value: function renderCurve(needClip) {\n      var _this4 = this;\n      var _props4 = this.props,\n        points = _props4.points,\n        strokeDasharray = _props4.strokeDasharray,\n        isAnimationActive = _props4.isAnimationActive,\n        animationBegin = _props4.animationBegin,\n        animationDuration = _props4.animationDuration,\n        animationEasing = _props4.animationEasing,\n        onClick = _props4.onClick,\n        onMouseEnter = _props4.onMouseEnter,\n        onMouseLeave = _props4.onMouseLeave,\n        other = _objectWithoutProperties(_props4, ['points', 'strokeDasharray', 'isAnimationActive', 'animationBegin', 'animationDuration', 'animationEasing', 'onClick', 'onMouseEnter', 'onMouseLeave']);\n      var totalLength = this.state.totalLength;\n      var animationProps = {\n        isActive: isAnimationActive,\n        begin: animationBegin,\n        canBegin: totalLength > 0,\n        easing: animationEasing,\n        duration: animationDuration,\n        onAnimationEnd: this.handleAnimationEnd,\n        onAnimationStart: this.handleAnimationStart,\n        shouldReAnimate: true,\n        pathRef: this.pathRef\n      };\n      var curveProps = _extends({}, other, {\n        fill: 'none',\n        className: 'recharts-line-curve',\n        clipPath: needClip ? 'url(#clipPath-' + this.id + ')' : null,\n        onClick: onClick,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        points: points\n      });\n      if (!isAnimationActive) {\n        return React.createElement(Curve, _extends({}, curveProps, {\n          strokeDasharray: strokeDasharray\n        }));\n      }\n      if (strokeDasharray && totalLength) {\n        var _ret2 = function () {\n          var lines = strokeDasharray.split(/[,\\s]+/gim).map(function (num) {\n            return parseFloat(num);\n          });\n          return {\n            v: React.createElement(Animate, _extends({}, animationProps, {\n              from: {\n                curveLen: 0\n              },\n              to: {\n                curveLen: totalLength\n              }\n            }), function (_ref2) {\n              var curveLen = _ref2.curveLen;\n              return React.createElement(Curve, _extends({}, curveProps, {\n                strokeDasharray: _this4.getStrokeDasharray(curveLen, totalLength, lines)\n              }));\n            })\n          };\n        }();\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      } else if (strokeDasharray) {\n        return React.createElement(Curve, _extends({}, curveProps, {\n          pathRef: this.pathRef,\n          strokeDasharray: strokeDasharray\n        }));\n      }\n      return React.createElement(Animate, _extends({}, animationProps, {\n        from: '0px ' + (totalLength === 0 ? 1 : totalLength) + 'px',\n        to: totalLength + 'px 0px',\n        attributeName: 'strokeDasharray'\n      }), React.createElement(Curve, curveProps));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props5 = this.props,\n        dot = _props5.dot,\n        points = _props5.points,\n        label = _props5.label,\n        className = _props5.className,\n        xAxis = _props5.xAxis,\n        yAxis = _props5.yAxis,\n        top = _props5.top,\n        left = _props5.left,\n        width = _props5.width,\n        height = _props5.height;\n      if (!points || !points.length) {\n        return null;\n      }\n      var hasSinglePoint = points.length === 1;\n      var layerClass = classNames('recharts-line', className);\n      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;\n      return React.createElement(Layer, {\n        className: layerClass\n      }, needClip ? React.createElement('defs', null, React.createElement('clipPath', {\n        id: 'clipPath-' + this.id\n      }, React.createElement('rect', {\n        x: left,\n        y: top,\n        width: width,\n        height: height\n      }))) : null, !hasSinglePoint && this.renderCurve(needClip), this.renderErrorBar(), (hasSinglePoint || dot) && this.renderDots(), label && this.renderLabels());\n    }\n  }]);\n  return Line;\n}(Component), _class2.displayName = 'Line', _class2.propTypes = _extends({}, PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, {\n  className: PropTypes.string,\n  type: PropTypes.oneOfType([PropTypes.oneOf(['basis', 'basisClosed', 'basisOpen', 'linear', 'linearClosed', 'natural', 'monotoneX', 'monotoneY', 'monotone', 'step', 'stepBefore', 'stepAfter']), PropTypes.func]),\n  unit: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  name: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  yAxisId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  xAxisId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  yAxis: PropTypes.object,\n  xAxis: PropTypes.object,\n  legendType: PropTypes.oneOf(LEGEND_TYPES),\n  layout: PropTypes.oneOf(['horizontal', 'vertical']),\n  connectNulls: PropTypes.bool,\n  // whether have dot in line\n  activeDot: PropTypes.oneOfType([PropTypes.object, PropTypes.element, PropTypes.func, PropTypes.bool]),\n  dot: PropTypes.oneOfType([PropTypes.object, PropTypes.element, PropTypes.func, PropTypes.bool]),\n  label: PropTypes.oneOfType([PropTypes.object, PropTypes.element, PropTypes.func, PropTypes.bool]),\n  top: PropTypes.number,\n  left: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  points: PropTypes.arrayOf(PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number,\n    value: PropTypes.value\n  })),\n  onAnimationStart: PropTypes.func,\n  onAnimationEnd: PropTypes.func,\n  isAnimationActive: PropTypes.bool,\n  animationBegin: PropTypes.number,\n  animationDuration: PropTypes.number,\n  animationEasing: PropTypes.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']),\n  animationId: PropTypes.number\n}), _class2.defaultProps = {\n  xAxisId: 0,\n  yAxisId: 0,\n  connectNulls: false,\n  activeDot: true,\n  dot: true,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  fill: '#fff',\n  points: [],\n  isAnimationActive: !isSsr(),\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  onAnimationStart: function onAnimationStart() {},\n  onAnimationEnd: function onAnimationEnd() {}\n}, _temp2)) || _class;\nexport default Line;","map":null,"metadata":{},"sourceType":"module"}